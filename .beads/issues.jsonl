{"id":"dox-0dn","title":"Update README and create documentation for query commands","description":"## Overview\nUpdate the README.md with documentation for the new query commands and create supporting docs.\n\n## Dependencies\n- All query commands must be implemented\n\n## Files to Modify\n\n### `README.md`\nAdd a new section after the existing Usage section:\n\n**\"Query Documentation\" section:**\n- Brief overview: browse and read synced docs via CLI\n- Quick start example:\n  ```bash\n  dox sync\n  dox collections\n  dox files goreleaser\n  dox cat goreleaser docs/install.md\n  dox outline goreleaser docs/install.md\n  ```\n- Document each command with options and examples\n- Add \"AI Agent Integration\" subsection showing workflow\n- Document [display] config options\n\n**\"Troubleshooting\" subsection:**\n- \"Manifest not found\" → run `dox sync`\n- \"Collection not found\" → run `dox collections`\n\n### `CONTRIBUTING.md` (if exists)\nAdd note about query feature and parser extension.\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- All README examples are accurate and tested\n- Documentation covers all 4 query commands\n\n## Commit\n```bash\ngit add README.md CONTRIBUTING.md\ngit commit -m \"docs: add query commands documentation to README\"\n```","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:27:58.263895-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T22:04:38.587367-05:00","closed_at":"2026-02-08T22:04:38.587367-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-0dn","depends_on_id":"dox-32p","type":"blocks","created_at":"2026-02-08T19:37:02.400723-05:00","created_by":"Takin Profit"},{"issue_id":"dox-0dn","depends_on_id":"dox-xbq","type":"blocks","created_at":"2026-02-08T19:37:05.669677-05:00","created_by":"Takin Profit"},{"issue_id":"dox-0dn","depends_on_id":"dox-asf","type":"blocks","created_at":"2026-02-08T19:37:08.919898-05:00","created_by":"Takin Profit"},{"issue_id":"dox-0dn","depends_on_id":"dox-ax0","type":"blocks","created_at":"2026-02-08T19:37:12.509545-05:00","created_by":"Takin Profit"},{"issue_id":"dox-0dn","depends_on_id":"dox-wek","type":"blocks","created_at":"2026-02-08T19:37:15.417327-05:00","created_by":"Takin Profit"}]}
{"id":"dox-0vk","title":"Add Display config section to dox.toml","description":"## Overview\nAdd the [display] configuration section to dox.toml for query command defaults. Extend the Config struct, loading, validation, and defaults.\n\n## Dependencies\n- None (independent of parser/manifest work)\n\n## Files to Modify\n\n### `internal/config/types.go`\nAdd Display struct and field to Config:\n```go\ntype Display struct {\n    DefaultLimit      int      `koanf:\"default_limit\"`\n    DescriptionLength int      `koanf:\"description_length\"`\n    LineNumbers       bool     `koanf:\"line_numbers\"`\n    Format            string   `koanf:\"format\"            validate:\"omitempty,oneof=table json csv\"`\n    ListFields        []string `koanf:\"list_fields\"`\n}\n```\n\nAdd to Config struct:\n```go\ntype Config struct {\n    // ... existing fields ...\n    Display Display `koanf:\"display\"`\n}\n```\n\nAdd defaults in ApplyDefaults():\n```go\nfunc (c *Config) ApplyDefaults() {\n    // ... existing defaults ...\n    \n    if c.Display.DefaultLimit == 0 {\n        c.Display.DefaultLimit = 50\n    }\n    if c.Display.DescriptionLength == 0 {\n        c.Display.DescriptionLength = 200\n    }\n    // LineNumbers defaults to false (zero value), set to true\n    // Only set if not explicitly configured - use a pointer or separate flag\n    // Simplest: always default to true in ApplyDefaults\n    if c.Display.Format == \"\" {\n        c.Display.Format = \"table\"\n    }\n    if len(c.Display.ListFields) == 0 {\n        c.Display.ListFields = []string{\"path\", \"type\", \"lines\", \"size\", \"description\"}\n    }\n}\n```\n\n**Note on LineNumbers default:** Since bool zero value is false but we want default true, consider using `*bool` pointer in the struct or handle it differently. The simplest approach: since koanf only sets values that exist in TOML, we can check if the koanf key was set. Alternative: just always set it true in ApplyDefaults and let users override to false.\n\n### `internal/config/config.go`\nNo changes needed - koanf automatically unmarshals [display] section.\nValidation already handles struct tags via go-playground/validator.\n\n### Test Updates in `internal/config/*_test.go`\nAdd tests:\n- Config with [display] section loads correctly\n- Config without [display] section gets defaults\n- Config with partial [display] (only some fields) gets defaults for missing\n- Invalid format value (\"xml\") fails validation\n- All field names in list_fields are valid\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes including new tests\n- Existing tests still pass (no regression)\n\n## Commit\n```bash\ngit add internal/config/types.go internal/config/config.go internal/config/*_test.go\ngit commit -m \"feat: add [display] config section for query command defaults\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:26:11.73366-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:01:17.504832-05:00","closed_at":"2026-02-08T20:01:17.504832-05:00","close_reason":"Closed"}
{"id":"dox-0wr","title":"Implement markdown parser","description":"## Overview\nImplement the markdown parser using gomarkdown/markdown library. Extracts headings and description from .md files.\n\n## Dependencies\n- gomarkdown/markdown dependency must be added\n- Parser interface and utilities must exist\n\n## Files to Create\n\n### `internal/parser/markdown.go`\n```go\npackage parser\n\nimport (\n    \"github.com/gomarkdown/markdown/ast\"\n    \"github.com/gomarkdown/markdown/parser\"\n)\n\ntype MarkdownParser struct{}\n\nfunc NewMarkdownParser() *MarkdownParser { return \u0026MarkdownParser{} }\n\nfunc (p *MarkdownParser) CanParse(path string) bool {\n    return DetectFileType(path) == \"md\"\n}\n\nfunc (p *MarkdownParser) Parse(path string, content []byte) (*ParseResult, error) {\n    // 1. StripBOM\n    // 2. StripFrontmatter - check for title/description\n    // 3. Parse markdown using gomarkdown parser with CommonExtensions\n    // 4. Walk AST with ast.WalkFunc to extract headings\n    // 5. Build description:\n    //    a. If frontmatter has title/description, use those\n    //    b. Else use first H1 heading text\n    //    c. If H1 followed by paragraph, append: \"Title - Paragraph text\"\n    //    d. If no H1, use first non-empty paragraph\n    // 6. Return ParseResult with headings outline and description\n}\n```\n\n**Key implementation details:**\n- Use `parser.NewWithExtensions(parser.CommonExtensions)` to create parser\n- Walk AST with `ast.WalkFunc(doc, func(node ast.Node, entering bool) ast.WalkStatus {...})`\n- For headings: check `node.(*ast.Heading)` when entering=true\n- Extract text from heading children (ast.Text nodes)\n- Track line numbers by counting newlines in content up to node position\n- Handle ATX headings (# style) - these are the standard ast.Heading nodes\n- Handle empty files gracefully (return empty description, empty outline)\n- Handle code-only markdown (no headings) - use first paragraph\n\n### `internal/parser/markdown_test.go`\nTable-driven tests:\n- ATX headings: `# H1`, `## H2`, etc.\n- File with frontmatter (title + description)\n- File without frontmatter\n- Markdown with only code blocks (no headings)\n- Empty file\n- Escaped headings inside code fences (should be ignored)\n- Multiple H1 headings (use first)\n- Deep heading hierarchy (h1 through h6)\n\n## Patterns to Follow\n- Follow existing test patterns in codebase\n- Use t.TempDir() for any file operations\n- Return errors wrapped with descriptive messages\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes including new tests\n- Correctly extracts headings from real-world markdown files\n\n## Commit\n```bash\ngit add internal/parser/markdown.go internal/parser/markdown_test.go\ngit commit -m \"feat: implement markdown parser with heading extraction\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:21:44.100224-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:10:14.310352-05:00","closed_at":"2026-02-08T20:10:14.310352-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-0wr","depends_on_id":"dox-gij","type":"blocks","created_at":"2026-02-08T19:35:57.535997-05:00","created_by":"Takin Profit"},{"issue_id":"dox-0wr","depends_on_id":"dox-cyh","type":"blocks","created_at":"2026-02-08T19:36:01.079188-05:00","created_by":"Takin Profit"}]}
{"id":"dox-14k","title":"Add direct dependencies to go.mod","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:34.609973-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T16:43:24.133255-05:00","closed_at":"2026-02-06T16:43:24.133255-05:00","close_reason":"Closed"}
{"id":"dox-1gd","title":"Fix resolveSourceLocation empty string edge case","description":"## Problem\n\n**internal/manifest/generator.go:142-147** — `resolveSourceLocation` returns an empty string if a source has neither Repo nor URL:\n\n```go\nfunc resolveSourceLocation(src config.Source) string {\n    if src.Repo != \"\" {\n        return src.Repo\n    }\n    return src.URL\n}\n```\n\nWhile config validation should prevent this, defensive coding requires handling the edge case. An empty `Source` field in the manifest is confusing.\n\n## Implementation Steps\n\n### Step 1: Add fallback\n\nIn `internal/manifest/generator.go`, update the function:\n\n```go\nfunc resolveSourceLocation(src config.Source) string {\n    if src.Repo != \"\" {\n        return src.Repo\n    }\n    if src.URL != \"\" {\n        return src.URL\n    }\n    return \"unknown\"\n}\n```\n\n### Step 2: Add test\n\nIn `internal/manifest/generator_test.go`, add a test for this edge case. Create a test that calls Generate with a source that has an empty sourceDir (so it gets skipped) and verify the manifest is valid.\n\n### Step 3: Verify\n\n```bash\ngo build ./...\ngo test ./internal/manifest/...\n```\n\n## Acceptance Criteria\n\n- [ ] `resolveSourceLocation` returns \"unknown\" when both Repo and URL are empty\n- [ ] Test covers the edge case\n- [ ] `go build ./...` succeeds\n- [ ] `go test ./...` passes\n\n## Commit\n\n```bash\ngit add internal/manifest/\ngit commit -m \"fix: handle empty source location in manifest generator\"\n```","status":"in_progress","priority":2,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:39:58.778442-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T23:26:38.886563-05:00","dependencies":[{"issue_id":"dox-1gd","depends_on_id":"dox-ub5","type":"blocks","created_at":"2026-02-08T22:52:25.646544-05:00","created_by":"Takin Profit"}]}
{"id":"dox-1md","title":"Update dox init template with [display] section","description":"## Overview\nUpdate the `dox init` command template to include the [display] configuration section with comments explaining each option.\n\n## Dependencies\n- Display config must exist in types.go\n\n## Files to Modify\n\n### `cmd/dox/main.go`\nFind the init command template (the TOML string in initAction) and add the [display] section:\n\n```toml\n# Query command defaults (used by: dox collections, dox files, dox cat, dox outline)\n# [display]\n# Number of files to show in 'dox files' (0 = all)\n# default_limit = 50\n#\n# Maximum length for file descriptions\n# description_length = 200\n#\n# Show line numbers in 'dox cat' by default\n# line_numbers = true\n#\n# Default output format: table, json, csv\n# format = \"table\"\n#\n# Default fields for 'dox files' table\n# list_fields = [\"path\", \"type\", \"lines\", \"size\", \"description\"]\n```\n\n**Note:** The section should be commented out by default (like typical config templates) so users can uncomment what they need.\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes\n- Running `dox init` in a new directory creates a dox.toml containing the [display] section comments\n\n## Commit\n```bash\ngit add cmd/dox/main.go\ngit commit -m \"feat: add [display] section to dox init template\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:27:48.21411-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:03:10.697903-05:00","closed_at":"2026-02-08T20:03:10.697903-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-1md","depends_on_id":"dox-0vk","type":"blocks","created_at":"2026-02-08T19:36:59.041552-05:00","created_by":"Takin Profit"}]}
{"id":"dox-1zc","title":"Implement table rendering with go-pretty","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:55.19185-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:37:31.599959-05:00","closed_at":"2026-02-06T18:37:31.599959-05:00","close_reason":"Closed"}
{"id":"dox-2dj","title":"dox v1 implementation","description":"Implement dox - a CLI tool that downloads library/framework documentation from configured sources to a local directory for AI agent RAG indexing via Codana","status":"closed","priority":1,"issue_type":"epic","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:24:51.391319-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T19:46:32.809742-05:00","closed_at":"2026-02-06T19:46:32.809742-05:00","close_reason":"Core implementation tasks completed; integration-test issue was closed with environment network-blocked reason."}
{"id":"dox-32p","title":"Implement dox collections command","description":"## Overview\nImplement the `dox collections` CLI command that lists all available documentation collections from the manifest.\n\n## Dependencies\n- Manifest types and persistence must exist (Load function)\n- Display config must exist (for format defaults)\n\n## Files to Create/Modify\n\n### `cmd/dox/collections.go` (NEW)\n```go\npackage main\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n\n    \"github.com/jedib0t/go-pretty/v6/table\"\n    \"github.com/urfave/cli/v3\"\n    \"github.com/g5becks/dox/internal/config\"\n    \"github.com/g5becks/dox/internal/manifest\"\n)\n\nfunc newCollectionsCommand() *cli.Command {\n    return \u0026cli.Command{\n        Name:  \"collections\",\n        Usage: \"List all documentation collections\",\n        Flags: []cli.Flag{\n            \u0026cli.BoolFlag{Name: \"json\", Usage: \"Output as JSON\"},\n            \u0026cli.IntFlag{Name: \"limit\", Usage: \"Limit number of results (0 = all)\"},\n        },\n        Action: collectionsAction,\n    }\n}\n\nfunc collectionsAction(ctx context.Context, cmd *cli.Command) error {\n    // 1. Load config using existing pattern (resolveConfig helper or config.Load)\n    // 2. Load manifest from cfg.Output directory\n    // 3. Build sorted list of collections (sort by name)\n    // 4. Apply --limit if set\n    // 5. If --json: marshal and print JSON array\n    // 6. Else: render table with columns: NAME, TYPE, FILES, SIZE, LAST SYNC\n    //    - Size formatted as human-readable (KB, MB)\n    //    - Last sync formatted as relative or absolute time\n    //    - Use go-pretty table.StyleRounded (matching existing ui patterns)\n}\n```\n\n**JSON output structure:**\n```json\n[\n  {\n    \"name\": \"goreleaser\",\n    \"type\": \"github\",\n    \"source\": \"goreleaser/goreleaser\",\n    \"path\": \"www/docs\",\n    \"files\": 142,\n    \"size\": 2201600,\n    \"last_sync\": \"2024-02-08T10:30:00Z\"\n  }\n]\n```\n\n**Table output:**\n```\nNAME         TYPE    FILES  SIZE     LAST SYNC\ngoreleaser   github    142  2.1 MB   2024-02-08 10:30\n```\n\n### `cmd/dox/main.go` (MODIFY)\nRegister the new command in the app's Commands slice:\n```go\nCommands: []*cli.Command{\n    // ... existing commands ...\n    newCollectionsCommand(),\n}\n```\n\n### Helper: `cmd/dox/format.go` (NEW - optional)\nCreate shared formatting helpers used by multiple commands:\n```go\npackage main\n\n// formatSize returns human-readable file size (e.g., \"2.1 MB\", \"156 KB\").\nfunc formatSize(bytes int64) string { ... }\n\n// formatTime returns formatted timestamp.\nfunc formatTime(t time.Time) string { ... }\n```\n\n## Patterns to Follow\n- Follow existing newListCommand() / newSyncCommand() patterns\n- Use go-pretty table.StyleRounded for table output\n- Use json.MarshalIndent for JSON output to stdout\n- Load config using same pattern as syncAction (config flag or FindConfigFile)\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes\n- `dox collections` prints table of collections\n- `dox collections --json` prints valid JSON array\n- `dox collections --limit 2` limits output\n\n## Commit\n```bash\ngit add cmd/dox/collections.go cmd/dox/format.go cmd/dox/main.go\ngit commit -m \"feat: implement dox collections command\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:26:33.636746-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:34:42.318374-05:00","closed_at":"2026-02-08T20:34:42.318374-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-32p","depends_on_id":"dox-8a3","type":"blocks","created_at":"2026-02-08T19:36:38.65849-05:00","created_by":"Takin Profit"},{"issue_id":"dox-32p","depends_on_id":"dox-0vk","type":"blocks","created_at":"2026-02-08T19:36:42.069601-05:00","created_by":"Takin Profit"}]}
{"id":"dox-4aj","title":"Write config package tests","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:40.96137-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T17:27:40.547554-05:00","closed_at":"2026-02-06T17:27:40.547554-05:00","close_reason":"Closed"}
{"id":"dox-4cc","title":"Wire clean command","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:59.776343-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:53:11.137824-05:00","closed_at":"2026-02-06T18:53:11.137824-05:00","close_reason":"Closed"}
{"id":"dox-50h","title":"Implement config types and defaults","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:38.109716-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T17:04:07.099271-05:00","closed_at":"2026-02-06T17:04:07.099271-05:00","close_reason":"Closed"}
{"id":"dox-51v","title":"Implement URL source with conditional requests","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:46.850995-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:17:32.855342-05:00","closed_at":"2026-02-06T18:17:32.855342-05:00","close_reason":"Closed"}
{"id":"dox-56k","title":"Query Feature: Browse and Read Documentation Collections","description":"Add CLI query commands (collections, files, cat, outline) to enable AI agents to discover and read synced documentation without external tools. Replaces MCP servers like context7. See QUERY_FEATURE_IMPLEMENTATION.md for full design.","status":"closed","priority":1,"issue_type":"feature","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:18:31.584013-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T22:11:56.142163-05:00","closed_at":"2026-02-08T22:11:56.142163-05:00","close_reason":"Closed"}
{"id":"dox-5ci","title":"Implement TypeScript/TSX parser","description":"## Overview\nImplement the TypeScript/TSX parser that detects documentation components (JSX with headings) vs code components (exports), extracting the appropriate structure from each.\n\n## Dependencies\n- Parser interface and utilities must exist\n\n## Files to Create\n\n### `internal/parser/typescript.go`\n```go\npackage parser\n\nimport \"regexp\"\n\n// Compile regex patterns once at package init\nvar (\n    jsxHeadingRegex = regexp.MustCompile(\\`\u003ch([1-6])[^\u003e]*\u003e(.*?)\u003c/h\\1\u003e\\`)\n    exportRegex     = regexp.MustCompile(\\`(?m)^\\s*export\\s+(const|function|interface|type|class)\\s+(\\w+)\\`)\n    jsdocRegex      = regexp.MustCompile(\\`(?s)/\\*\\*\\s*\\n(.*?)\\*/\\`)\n    jsxTagStripper  = regexp.MustCompile(\\`\u003c[^\u003e]+\u003e\\`)\n)\n\ntype TypeScriptParser struct{}\n\nfunc NewTypeScriptParser() *TypeScriptParser { return \u0026TypeScriptParser{} }\n\nfunc (p *TypeScriptParser) CanParse(path string) bool {\n    ft := DetectFileType(path)\n    return ft == \"tsx\" || ft == \"ts\"\n}\n\nfunc (p *TypeScriptParser) Parse(path string, content []byte) (*ParseResult, error) {\n    // 1. StripBOM\n    // 2. Count lines\n    // 3. Extract JSX headings using jsxHeadingRegex\n    //    - For each match: get heading level (group 1), text (group 2)\n    //    - Strip nested tags from text using jsxTagStripper\n    //    - Calculate line number by counting newlines before match position\n    // 4. Determine component type:\n    //    - If \u003e= 2 headings with non-empty text -\u003e documentation component\n    //    - Otherwise -\u003e code component\n    // 5. If documentation component:\n    //    - Description = first \u003ch1\u003e text, or first heading text\n    //    - Outline = headings list\n    // 6. If code component:\n    //    - Extract exports using exportRegex\n    //    - Description from JSDoc (jsdocRegex) or first comment\n    //    - Outline = exports list\n    // 7. Return ParseResult with appropriate ComponentType\n}\n\n// Helper: calculate line number from byte offset in content\nfunc lineNumberAt(content []byte, offset int) int { ... }\n```\n\n### `internal/parser/typescript_test.go`\nTable-driven tests:\n- TSX documentation component (multiple JSX headings like \u003ch1\u003eTitle\u003c/h1\u003e)\n- TSX code component (exports, interfaces)\n- TSX with JSDoc comment\n- TSX with nested tags in headings (e.g., \u003ch1\u003e\u003ccode\u003efoo\u003c/code\u003e bar\u003c/h1\u003e)\n- TSX with only imports (no headings, no exports)\n- TS file with exports\n- TS file with JSDoc\n- TSX with exactly 1 heading (should be code component)\n- TSX with exactly 2 headings (should be documentation component)\n- Empty file\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes including new tests\n- Correctly identifies the CDP Mode example from QUERY_FEATURE_IMPLEMENTATION.md as a documentation component\n\n## Commit\n```bash\ngit add internal/parser/typescript.go internal/parser/typescript_test.go\ngit commit -m \"feat: implement TypeScript/TSX parser with doc component detection\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:22:18.644361-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:42:38.530025-05:00","closed_at":"2026-02-08T20:42:38.530025-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-5ci","depends_on_id":"dox-gij","type":"blocks","created_at":"2026-02-08T19:36:11.885926-05:00","created_by":"Takin Profit"}]}
{"id":"dox-7or","title":"Create directory structure","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:33.138976-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T15:45:32.03874-05:00","closed_at":"2026-02-06T15:45:32.03874-05:00","close_reason":"Closed"}
{"id":"dox-7pn","title":"Write lockfile package tests","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:43.736408-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:01:19.739296-05:00","closed_at":"2026-02-06T18:01:19.739296-05:00","close_reason":"Closed"}
{"id":"dox-8a3","title":"Create manifest package with types and persistence","description":"## Overview\nCreate the `internal/manifest` package with type definitions and Load/Save operations following the lockfile pattern (atomic writes via temp file + rename).\n\n## Dependencies\n- Parser package interface must exist (for Outline, Heading, Export types - import from parser package)\n\n## Files to Create\n\n### `internal/manifest/manifest.go`\n```go\npackage manifest\n\nimport (\n    \"encoding/json\"\n    \"os\"\n    \"path/filepath\"\n    \"time\"\n\n    \"github.com/samber/oops\"\n    \"github.com/g5becks/dox/internal/parser\"\n)\n\nconst (\n    CurrentVersion = \"1.0.0\"\n    ManifestFile   = \"manifest.json\"\n)\n\ntype Manifest struct {\n    Version     string                 `json:\"version\"`\n    Generated   time.Time              `json:\"generated\"`\n    Collections map[string]*Collection `json:\"collections\"`\n}\n\ntype Collection struct {\n    Name      string     `json:\"name\"`\n    Type      string     `json:\"type\"`\n    Source    string     `json:\"source\"`\n    Path      string     `json:\"path,omitempty\"`\n    Ref       string     `json:\"ref,omitempty\"`\n    LastSync  time.Time  `json:\"last_sync\"`\n    FileCount int        `json:\"file_count\"`\n    TotalSize int64      `json:\"total_size\"`\n    Files     []FileInfo `json:\"files\"`\n}\n\ntype FileInfo struct {\n    Path          string               `json:\"path\"`\n    Type          string               `json:\"type\"`\n    Size          int64                `json:\"size\"`\n    Lines         int                  `json:\"lines\"`\n    Modified      time.Time            `json:\"modified\"`\n    Description   string               `json:\"description\"`\n    ComponentType parser.ComponentType  `json:\"component_type,omitempty\"`\n    Warning       string               `json:\"warning,omitempty\"`\n    Outline       *parser.Outline      `json:\"outline,omitempty\"`\n}\n\nfunc New() *Manifest {\n    return \u0026Manifest{\n        Version:     CurrentVersion,\n        Generated:   time.Now(),\n        Collections: make(map[string]*Collection),\n    }\n}\n\n// Load reads manifest from outputDir/manifest.json.\n// Returns error with hint if missing or corrupted.\nfunc Load(outputDir string) (*Manifest, error) {\n    // Follow lockfile.Load pattern:\n    // 1. Build path: filepath.Join(outputDir, ManifestFile)\n    // 2. ReadFile - if os.ErrNotExist, return MANIFEST_NOT_FOUND error with hint\n    // 3. json.Unmarshal - if error, return MANIFEST_CORRUPTED with hint\n    // 4. Validate version - if mismatch, log warning but continue\n    // 5. Initialize nil maps\n}\n\n// Save writes manifest atomically (temp file + rename).\n// Follow lockfile.Save pattern exactly.\nfunc (m *Manifest) Save(outputDir string) error {\n    // 1. MkdirAll for outputDir\n    // 2. json.MarshalIndent with \"  \" indent + newline\n    // 3. CreateTemp in outputDir\n    // 4. Write to temp, close, rename to manifest.json\n    // 5. Defer os.Remove(tempPath) for cleanup on error\n}\n\n// ManifestPath returns the full path to manifest.json.\nfunc ManifestPath(outputDir string) string {\n    return filepath.Join(outputDir, ManifestFile)\n}\n```\n\n**Error codes to use:**\n- `MANIFEST_NOT_FOUND` with hint \"Run 'dox sync' to generate the manifest\"\n- `MANIFEST_CORRUPTED` with hint \"Delete .dox/manifest.json and run 'dox sync'\"\n- `MANIFEST_WRITE_ERROR` for save failures\n\n### `internal/manifest/manifest_test.go`\nTable-driven tests:\n- New() creates valid manifest with version and empty collections\n- Save then Load round-trip\n- Load non-existent file returns MANIFEST_NOT_FOUND error\n- Load corrupted JSON returns MANIFEST_CORRUPTED error\n- Save creates directory if missing\n- Atomic write: verify temp file cleanup on success\n\n## Patterns to Follow\n- Follow internal/lockfile/lockfile.go Save/Load pattern exactly\n- Use oops for all errors with codes and hints\n- Use t.TempDir() for test directories\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes including new tests\n\n## Commit\n```bash\ngit add internal/manifest/\ngit commit -m \"feat: create manifest package with types and persistence\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:23:42.038915-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:28:27.507807-05:00","closed_at":"2026-02-08T20:28:27.507807-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-8a3","depends_on_id":"dox-gij","type":"blocks","created_at":"2026-02-08T19:36:15.125155-05:00","created_by":"Takin Profit"}]}
{"id":"dox-8p6","title":"Implement config loading with koanf","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:39.575012-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T17:21:55.078449-05:00","closed_at":"2026-02-06T17:21:55.078449-05:00","close_reason":"Closed"}
{"id":"dox-8zf","title":"Fix generator silent error swallowing (nilerr)","description":"## Problem\n\n**CRITICAL** — internal/manifest/generator.go:56-58 silently swallows parse errors:\n\n```go\nfileInfo, parseErr := parseFile(path, relPath, parsers)\nif parseErr != nil {\n    return nil  // nilerr: error is not nil but returns nil\n}\n```\n\nThe linter reports: `error is not nil (line 56) but it returns nil (nilerr)`\n\nThis is inside a `filepath.WalkDir` callback where returning nil means \"continue walking\". The intent is correct (skip unparseable files), but:\n1. The linter flags it as a likely bug\n2. There is ZERO logging — files that fail to parse are completely invisible\n3. Debugging manifest issues becomes impossible\n\n## Implementation Steps\n\n### Step 1: Add a skip counter and warning list\n\nIn `internal/manifest/generator.go`, modify the `Generate` function to track skipped files:\n\n```go\nfunc Generate(_ context.Context, cfg *config.Config) error {\n    outputDir := cfg.Output\n    m := New()\n    \n    parsers := []parser.Parser{\n        parser.NewMarkdownParser(),\n        parser.NewMDXParser(),\n        parser.NewTextParser(),\n        parser.NewTypeScriptParser(),\n    }\n    \n    for sourceName, sourceCfg := range cfg.Sources {\n        sourceDir := resolveSourceDir(outputDir, sourceName, sourceCfg)\n        \n        if _, err := os.Stat(sourceDir); os.IsNotExist(err) {\n            continue\n        }\n        \n        collection := \u0026Collection{\n            Name:     sourceName,\n            Type:     sourceCfg.Type,\n            Source:   resolveSourceLocation(sourceCfg),\n            Path:     sourceCfg.Path,\n            Ref:      sourceCfg.Ref,\n            LastSync: time.Now(),\n        }\n        \n        var skipped int\n        \n        err := filepath.WalkDir(sourceDir, func(path string, d os.DirEntry, walkErr error) error {\n            if walkErr != nil || d.IsDir() {\n                return walkErr\n            }\n            \n            if d.Name() == ManifestFile || d.Name() == \".dox.lock\" {\n                return nil\n            }\n            \n            relPath, _ := filepath.Rel(sourceDir, path)\n            fileInfo, parseErr := parseFile(path, relPath, parsers)\n            if parseErr != nil {\n                skipped++\n                return nil //nolint:nilerr // intentionally skip unparseable files (binary, etc.)\n            }\n            \n            collection.Files = append(collection.Files, *fileInfo)\n            collection.TotalSize += fileInfo.Size\n            return nil\n        })\n        \n        if err != nil {\n            return oops.\n                Code(\"MANIFEST_GENERATION_ERROR\").\n                With(\"source\", sourceName).\n                Wrapf(err, \"walking source directory\")\n        }\n        \n        collection.FileCount = len(collection.Files)\n        collection.Skipped = skipped\n        m.Collections[sourceName] = collection\n    }\n    \n    return m.Save(outputDir)\n}\n```\n\n### Step 2: Add Skipped field to Collection\n\nIn `internal/manifest/manifest.go`, add the field to the Collection struct:\n\n```go\ntype Collection struct {\n    Name      string     `json:\"name\"`\n    Type      string     `json:\"type\"`\n    Source    string     `json:\"source\"`\n    Path      string     `json:\"path,omitempty\"`\n    Ref       string     `json:\"ref,omitempty\"`\n    LastSync  time.Time  `json:\"last_sync\"`\n    FileCount int        `json:\"file_count\"`\n    TotalSize int64      `json:\"total_size\"`\n    Skipped   int        `json:\"skipped,omitempty\"`\n    Files     []FileInfo `json:\"files\"`\n}\n```\n\n### Step 3: Update tests\n\nUpdate any tests that check Collection struct fields to include the new Skipped field where relevant. The existing tests should still pass since Skipped defaults to 0.\n\n### Step 4: Verify\n\n```bash\ngolangci-lint run ./internal/manifest/...\ngo test ./internal/manifest/...\ngo build ./...\n```\n\nThe nilerr warning should be gone (suppressed by the nolint comment with explanation).\n\n## Acceptance Criteria\n\n- [ ] The `//nolint:nilerr` comment with explanation is present\n- [ ] Collection struct has `Skipped int` field with `json:\"skipped,omitempty\"`\n- [ ] `golangci-lint run ./...` no longer reports nilerr\n- [ ] `go build ./...` succeeds\n- [ ] `go test ./...` passes\n\n## Commit\n\n```bash\ngit add internal/manifest/\ngit commit -m \"fix: add nolint annotation and skip counter for unparseable files in generator\"\n```","status":"closed","priority":0,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:39:40.00131-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T23:10:43.872151-05:00","closed_at":"2026-02-08T23:10:43.872151-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-8zf","depends_on_id":"dox-ub5","type":"blocks","created_at":"2026-02-08T22:52:25.148107-05:00","created_by":"Takin Profit"}]}
{"id":"dox-9dl","title":"Implement MDX parser","description":"## Overview\nImplement the MDX parser that reuses the markdown parser. MDX files are markdown with JSX components - we strip JSX imports and treat the rest as markdown.\n\n## Dependencies\n- Markdown parser must be implemented\n\n## Files to Create\n\n### `internal/parser/mdx.go`\n```go\npackage parser\n\ntype MDXParser struct {\n    md *MarkdownParser\n}\n\nfunc NewMDXParser() *MDXParser {\n    return \u0026MDXParser{md: NewMarkdownParser()}\n}\n\nfunc (p *MDXParser) CanParse(path string) bool {\n    return DetectFileType(path) == \"mdx\"\n}\n\nfunc (p *MDXParser) Parse(path string, content []byte) (*ParseResult, error) {\n    // 1. StripBOM\n    // 2. StripFrontmatter (MDX commonly has frontmatter)\n    // 3. Remove import lines: lines starting with \"import \" (regex or string prefix)\n    // 4. Remove export lines that aren't content: \"export const metadata = ...\"\n    // 5. Pass cleaned content to MarkdownParser.Parse()\n    // 6. If frontmatter had title/description, override the description\n    // 7. Return ParseResult\n}\n```\n\n**Key implementation details:**\n- Strip lines matching `^\\s*import\\s+` pattern\n- Strip lines matching `^\\s*export\\s+(const|let|var)\\s+\\w+\\s*=` (metadata exports)\n- Keep `export default` lines (these wrap content)\n- After stripping, delegate to MarkdownParser for heading extraction\n- Frontmatter title/description takes priority over content extraction\n\n### `internal/parser/mdx_test.go`\nTable-driven tests:\n- MDX with frontmatter (title + description)\n- MDX with frontmatter (title only)\n- MDX without frontmatter\n- MDX with import statements (should be stripped)\n- MDX with embedded JSX components (components ignored, headings extracted)\n- MDX with export const metadata (should be stripped)\n- Empty MDX file\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes including new tests\n\n## Commit\n```bash\ngit add internal/parser/mdx.go internal/parser/mdx_test.go\ngit commit -m \"feat: implement MDX parser with frontmatter and import handling\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:21:54.849234-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:19:41.396109-05:00","closed_at":"2026-02-08T20:19:41.396109-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-9dl","depends_on_id":"dox-0wr","type":"blocks","created_at":"2026-02-08T19:36:05.066554-05:00","created_by":"Takin Profit"}]}
{"id":"dox-9hc","title":"Implement lock file operations","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:42.319265-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T17:31:42.417699-05:00","closed_at":"2026-02-06T17:31:42.417699-05:00","close_reason":"Closed"}
{"id":"dox-a82","title":"Implement text parser","description":"## Overview\nImplement a simple text parser that extracts the first non-empty line as description. Text files have no structural outline.\n\n## Dependencies\n- Parser interface and utilities must exist\n\n## Files to Create\n\n### `internal/parser/text.go`\n```go\npackage parser\n\ntype TextParser struct{}\n\nfunc NewTextParser() *TextParser { return \u0026TextParser{} }\n\nfunc (p *TextParser) CanParse(path string) bool {\n    return DetectFileType(path) == \"txt\"\n}\n\nfunc (p *TextParser) Parse(path string, content []byte) (*ParseResult, error) {\n    // 1. StripBOM\n    // 2. Count lines\n    // 3. Find first non-empty line (trimmed) as description\n    // 4. Return ParseResult with OutlineTypeNone, no headings/exports\n}\n```\n\n### `internal/parser/text_test.go`\nTable-driven tests:\n- Plain text file with content\n- Empty file\n- File with leading blank lines\n- File with only whitespace\n- Very long first line (should be truncated in description)\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes including new tests\n\n## Commit\n```bash\ngit add internal/parser/text.go internal/parser/text_test.go\ngit commit -m \"feat: implement text parser\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:22:03.470424-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:18:05.767764-05:00","closed_at":"2026-02-08T20:18:05.767764-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-a82","depends_on_id":"dox-gij","type":"blocks","created_at":"2026-02-08T19:36:08.664395-05:00","created_by":"Takin Profit"}]}
{"id":"dox-asf","title":"Implement dox cat command","description":"## Overview\nImplement the `dox cat \u003ccollection\u003e \u003cfile\u003e` command to read and display file contents with line numbers and pagination.\n\n## Dependencies\n- Manifest types and persistence must exist\n- Display config must exist\n\n## Files to Create/Modify\n\n### `cmd/dox/cat.go` (NEW)\n```go\npackage main\n\nfunc newCatCommand() *cli.Command {\n    return \u0026cli.Command{\n        Name:      \"cat\",\n        Usage:     \"Read file contents from a collection\",\n        ArgsUsage: \"\u003ccollection\u003e \u003cfile\u003e\",\n        Flags: []cli.Flag{\n            \u0026cli.BoolFlag{Name: \"json\", Usage: \"Output as JSON with metadata\"},\n            \u0026cli.BoolFlag{Name: \"no-line-numbers\", Usage: \"Don't show line numbers\"},\n            \u0026cli.IntFlag{Name: \"offset\", Usage: \"Start at line N (0-based)\"},\n            \u0026cli.IntFlag{Name: \"limit\", Usage: \"Show N lines (0 = all)\"},\n        },\n        Action: catAction,\n    }\n}\n\nfunc catAction(ctx context.Context, cmd *cli.Command) error {\n    // 1. Validate: require exactly 2 positional args (collection, file)\n    // 2. Load config and manifest\n    // 3. Look up collection - error if not found\n    // 4. Verify file exists in collection manifest AND on disk\n    //    - Build absolute path: cfg.Output / collection / file\n    //    - If file not on disk: error FILE_NOT_FOUND\n    // 5. Read file content\n    // 6. Split into lines\n    // 7. Apply offset and limit\n    // 8. If --json: output structured JSON with metadata\n    // 9. Else: print lines with line numbers (unless --no-line-numbers)\n    //    - Line number format: \"%6d  %s\" (right-aligned, 6 chars, 2 spaces)\n    //    - Line numbers are 1-based\n    //    - Respect config line_numbers setting (CLI flag overrides)\n}\n```\n\n**Default output (with line numbers):**\n```\n     1  # Installation\n     2\n     3  GoReleaser can be installed using various package managers.\n```\n\n**JSON output:**\n```json\n{\n  \"collection\": \"goreleaser\",\n  \"path\": \"docs/install.md\",\n  \"type\": \"md\",\n  \"lines\": 152,\n  \"size\": 4608,\n  \"content\": \"# Installation\\n\\nGoReleaser can be...\",\n  \"offset\": 0,\n  \"limit\": 152\n}\n```\n\n### `cmd/dox/main.go` (MODIFY)\nRegister: `newCatCommand()`\n\n## Error Handling\n- Collection not found: list available collections\n- File not found in manifest: suggest running dox files \u003ccollection\u003e\n- File exists in manifest but not on disk: suggest re-running dox sync\n- Offset beyond file length: empty output (no error)\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes\n- `dox cat goreleaser docs/install.md` shows file with line numbers\n- `dox cat goreleaser docs/install.md --no-line-numbers` shows raw content\n- `dox cat goreleaser docs/install.md --offset 10 --limit 5` shows 5 lines from line 10\n- `dox cat goreleaser docs/install.md --json` shows structured JSON\n\n## Commit\n```bash\ngit add cmd/dox/cat.go cmd/dox/main.go\ngit commit -m \"feat: implement dox cat command with pagination\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:27:16.079166-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:37:47.410931-05:00","closed_at":"2026-02-08T20:37:47.410931-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-asf","depends_on_id":"dox-8a3","type":"blocks","created_at":"2026-02-08T19:36:48.569094-05:00","created_by":"Takin Profit"},{"issue_id":"dox-asf","depends_on_id":"dox-0vk","type":"blocks","created_at":"2026-02-08T19:36:52.108961-05:00","created_by":"Takin Profit"}]}
{"id":"dox-ax0","title":"Implement dox outline command","description":"## Overview\nImplement the `dox outline \u003ccollection\u003e \u003cfile\u003e` command to display the document structure (headings for markdown/TSX docs, exports for TSX/TS code).\n\n## Dependencies\n- Manifest types and persistence must exist\n\n## Files to Create/Modify\n\n### `cmd/dox/outline.go` (NEW)\n```go\npackage main\n\nfunc newOutlineCommand() *cli.Command {\n    return \u0026cli.Command{\n        Name:      \"outline\",\n        Usage:     \"Show file structure (headings, exports)\",\n        ArgsUsage: \"\u003ccollection\u003e \u003cfile\u003e\",\n        Flags: []cli.Flag{\n            \u0026cli.BoolFlag{Name: \"json\", Usage: \"Output as JSON\"},\n        },\n        Action: outlineAction,\n    }\n}\n\nfunc outlineAction(ctx context.Context, cmd *cli.Command) error {\n    // 1. Validate: require exactly 2 positional args\n    // 2. Load config and manifest\n    // 3. Look up collection and file in manifest\n    // 4. Get file's outline from manifest FileInfo\n    // 5. If --json: output structured JSON\n    // 6. Else: render outline based on type:\n    //    a. OutlineTypeHeadings: show heading tree with indentation\n    //       Format: \"%3d  %s%s\" where indent is 2 spaces per level\n    //       Example:\n    //         1  # Installation\n    //         8    ## Package Managers\n    //        12      ### Homebrew\n    //    b. OutlineTypeExports: show export list\n    //       Format: \"%3d   %s %s\"\n    //       Example:\n    //         5   interface ButtonProps\n    //        15   export const Button\n    //    c. OutlineTypeNone: message \"No outline available for text files.\"\n    // 7. Print file header: \"filename (N lines, size)\"\n}\n```\n\n**Heading display (markdown, mdx, tsx-docs):**\n```\ndocs/install.md (152 lines, 4.5 KB)\n\nSTRUCTURE:\n  1  # Installation\n  8    ## Package Managers\n 12      ### Homebrew\n```\n\n**Export display (tsx-code, ts):**\n```\ncomponents/Button.tsx (45 lines, 1.2 KB)\n\nEXPORTS:\n  5   interface ButtonProps\n 15   export const Button\n```\n\n**No outline:**\n```\nREADME.txt (89 lines, 2.1 KB)\n\nNo outline available for text files.\nUse 'dox cat' to read the full content.\n```\n\n### `cmd/dox/main.go` (MODIFY)\nRegister: `newOutlineCommand()`\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes\n- `dox outline goreleaser docs/install.md` shows heading structure\n- `dox outline goreleaser docs/install.md --json` shows structured JSON\n- `dox outline goreleaser README.txt` shows \"no outline\" message\n\n## Commit\n```bash\ngit add cmd/dox/outline.go cmd/dox/main.go\ngit commit -m \"feat: implement dox outline command\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:27:37.928777-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:32:37.24515-05:00","closed_at":"2026-02-08T20:32:37.24515-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-ax0","depends_on_id":"dox-8a3","type":"blocks","created_at":"2026-02-08T19:36:55.380638-05:00","created_by":"Takin Profit"}]}
{"id":"dox-bsv","title":"Fix Query Feature Audit Issues","description":"Epic to fix all issues found during the query feature code audit.\n\nCovers 21 issues across 4 severity levels:\n- 1 Critical: generator silently swallows parse errors\n- 5 High: cat path resolution, timestamps, off-by-one, config, stdlib\n- 8 Medium: README mismatch, function placement, multi-line imports, benchmarks\n- 7 Low: linter warnings, test patterns, testdata\n\n14 tasks organized in 4 layers with proper dependencies.\nAll tasks must pass: task lint, task build, task test.","status":"open","priority":1,"issue_type":"epic","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:34:43.475267-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T22:34:51.161889-05:00"}
{"id":"dox-c7u","title":"Wire sync command","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:57.446588-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:46:17.972595-05:00","closed_at":"2026-02-06T18:46:17.972595-05:00","close_reason":"Closed"}
{"id":"dox-c8r","title":"Implement source interface and factory","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:45.431321-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:04:41.093919-05:00","closed_at":"2026-02-06T18:04:41.093919-05:00","close_reason":"Closed"}
{"id":"dox-cw6","title":"Wire add command","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:29:02.110496-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T19:03:39.43846-05:00","closed_at":"2026-02-06T19:03:39.43846-05:00","close_reason":"Closed"}
{"id":"dox-cyh","title":"Add gomarkdown/markdown dependency","description":"## Overview\nAdd the gomarkdown/markdown library as a project dependency for parsing .md and .mdx files.\n\n## Steps\n\n1. Run: `go get github.com/gomarkdown/markdown`\n2. Run: `go mod tidy`\n3. Verify the dependency appears in go.mod and go.sum\n\n## Acceptance Criteria\n- `go.mod` contains `github.com/gomarkdown/markdown`\n- `task build` succeeds with no new warnings\n- `task lint` has zero warnings or errors\n- `task test` passes (no regressions)\n\n## Commit\n```bash\ngit add go.mod go.sum\ngit commit -m \"feat: add gomarkdown/markdown dependency for doc parsing\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:21:21.377042-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T19:59:22.501854-05:00","closed_at":"2026-02-08T19:59:22.501854-05:00","close_reason":"Closed"}
{"id":"dox-dad","title":"Implement error summary in sync","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:29:05.50734-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T19:41:01.023019-05:00","closed_at":"2026-02-06T19:41:01.023019-05:00","close_reason":"Closed"}
{"id":"dox-eu9","title":"Add GitHub rate limit warnings","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:29:04.294326-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T19:36:45.279084-05:00","closed_at":"2026-02-06T19:36:45.279084-05:00","close_reason":"Closed"}
{"id":"dox-f0g","title":"Implement progress bar wrapper","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:53.926814-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:35:12.018877-05:00","closed_at":"2026-02-06T18:35:12.018877-05:00","close_reason":"Closed"}
{"id":"dox-f47","title":"Fix benchmark tests with proper Sources config","description":"## Problem\n\n**internal/manifest/bench_test.go:19** — All benchmarks create a config with an empty Sources map:\n\n\\`\\`\\`go\ncfg := \u0026config.Config{Output: doxDir}\n\\`\\`\\`\n\nThe \\`setupBenchmarkFiles\\` function creates files under a \\`bench/\\` subdirectory, but no source named \\`bench\\` is configured. Since \\`Generate\\` iterates \\`cfg.Sources\\` and none exist, it processes zero files. The benchmarks measure JSON loading but the generate benchmark is meaningless — it generates an empty manifest regardless of how many files exist on disk.\n\n## Implementation Steps\n\n### Step 1: Fix config in all benchmarks\n\nIn \\`internal/manifest/bench_test.go\\`, update each benchmark to include a proper Sources config:\n\n\\`\\`\\`go\ncfg := \u0026config.Config{\n    Output: doxDir,\n    Sources: map[string]config.Source{\n        \"bench\": {\n            Type: \"github\",\n            Repo: \"test/test\",\n            Path: \"docs\",\n        },\n    },\n}\n\\`\\`\\`\n\nApply this to all three benchmark functions:\n- \\`BenchmarkManifestLoad100Files\\` (line 14)\n- \\`BenchmarkManifestLoad1000Files\\` (line 33)\n- \\`BenchmarkManifestGenerate100Files\\` (line 52)\n\nNOTE: The Generate function signature may have changed to accept a lockfile parameter (see task dox-ji0). If so, pass nil: \\`manifest.Generate(context.Background(), cfg, nil)\\`\n\n### Step 2: Verify benchmarks actually do work\n\nRun the benchmarks and confirm they report meaningful times (not near-zero):\n\n\\`\\`\\`bash\ngo test -bench=. -benchtime=3s ./internal/manifest/...\n\\`\\`\\`\n\n### Step 3: Verify\n\n\\`\\`\\`bash\ngo test ./internal/manifest/...\ngo build ./...\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] All benchmarks have a proper Sources config with \\`\"bench\"\\` source\n- [ ] \\`BenchmarkManifestGenerate100Files\\` processes 100 files (not 0)\n- [ ] Benchmarks run and report meaningful timing\n- [ ] \\`go test ./...\\` passes\n\n## Commit\n\n\\`\\`\\`bash\ngit add internal/manifest/bench_test.go\ngit commit -m \"fix: add proper Sources config to manifest benchmarks\"\n\\`\\`\\`","status":"open","priority":3,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:47:14.863113-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T22:47:14.863113-05:00","dependencies":[{"issue_id":"dox-f47","depends_on_id":"dox-ub5","type":"blocks","created_at":"2026-02-08T22:52:28.388496-05:00","created_by":"Takin Profit"}]}
{"id":"dox-gij","title":"Create parser package with interface and utilities","description":"## Overview\nCreate the `internal/parser` package with the Parser interface, ParseResult types, and utility functions for binary detection, UTF-8 validation, BOM stripping, and file type detection.\n\n## Files to Create\n\n### `internal/parser/parser.go`\nDefine the Parser interface and result types:\n```go\npackage parser\n\n// Parser extracts description and outline from file content.\ntype Parser interface {\n    Parse(path string, content []byte) (*ParseResult, error)\n    CanParse(path string) bool\n}\n\ntype ParseResult struct {\n    Description   string\n    ComponentType ComponentType // only for tsx/ts\n    Outline       *Outline\n    Lines         int\n}\n\ntype Outline struct {\n    Type     OutlineType \\`json:\\\"type\\\"\\`\n    Headings []Heading   \\`json:\\\"headings,omitempty\\\"\\`\n    Exports  []Export    \\`json:\\\"exports,omitempty\\\"\\`\n}\n\ntype OutlineType string\n\nconst (\n    OutlineTypeHeadings OutlineType = \"headings\"\n    OutlineTypeExports  OutlineType = \"exports\"\n    OutlineTypeNone     OutlineType = \"none\"\n)\n\ntype ComponentType string\n\nconst (\n    ComponentTypeDocumentation ComponentType = \"documentation\"\n    ComponentTypeCode          ComponentType = \"code\"\n    ComponentTypeNone          ComponentType = \"\"\n)\n\ntype Heading struct {\n    Level int    \\`json:\\\"level\\\"\\`\n    Text  string \\`json:\\\"text\\\"\\`\n    Line  int    \\`json:\\\"line\\\"\\`\n}\n\ntype Export struct {\n    Type string \\`json:\\\"type\\\"\\`\n    Name string \\`json:\\\"name\\\"\\`\n    Line int    \\`json:\\\"line\\\"\\`\n}\n```\n\n### `internal/parser/utils.go`\nImplement utility functions:\n```go\npackage parser\n\n// IsBinary checks first 512 bytes for null bytes.\nfunc IsBinary(content []byte) bool { ... }\n\n// IsValidUTF8 validates the content is valid UTF-8.\nfunc IsValidUTF8(content []byte) bool { ... }\n\n// StripBOM removes UTF-8 BOM (0xEF, 0xBB, 0xBF) if present.\nfunc StripBOM(content []byte) []byte { ... }\n\n// DetectFileType maps file extension to type string.\n// Returns: \"md\", \"mdx\", \"txt\", \"tsx\", \"ts\", or \"unknown\"\nfunc DetectFileType(path string) string { ... }\n\n// StripFrontmatter removes YAML frontmatter (--- delimited) and returns\n// the remaining content and extracted title/description if present.\nfunc StripFrontmatter(content []byte) (body []byte, title string, description string) { ... }\n```\n\n### `internal/parser/utils_test.go`\nTable-driven tests following existing patterns (see internal/config/*_test.go):\n- IsBinary: null bytes, valid text, images\n- IsValidUTF8: valid, invalid, mixed\n- StripBOM: with BOM, without BOM\n- DetectFileType: all extensions (.md, .mdx, .txt, .tsx, .ts, .unknown)\n- StripFrontmatter: with title+desc, title only, no frontmatter, empty\n\n## Patterns to Follow\n- Use stdlib only: `unicode/utf8`, `bytes`, `strings`, `path/filepath`\n- Follow existing test patterns: table-driven with `t.Run()`\n- No external dependencies needed for this file\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes including new tests\n- All utility functions have \u003e90% test coverage\n\n## Commit\n```bash\ngit add internal/parser/\ngit commit -m \"feat: create parser package with interface and utilities\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:21:33.178638-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:07:21.658785-05:00","closed_at":"2026-02-08T20:07:21.658785-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-gij","depends_on_id":"dox-cyh","type":"blocks","created_at":"2026-02-08T19:35:53.685922-05:00","created_by":"Takin Profit"}]}
{"id":"dox-ji0","title":"Add Dir field to Collection and use lockfile timestamps","description":"## Problem\n\nTwo related issues in the manifest generator:\n\n1. **cat.go:112 path resolution ignores out config** — When a source has `out = \"custom-dir\"`, files live at `cfg.Output/custom-dir/...` but the cat command resolves to `cfg.Output/collectionName/...`. The manifest Collection does not store the resolved output directory, so commands cannot determine where files actually are on disk.\n\n2. **generator.go:43 wrong LastSync timestamp** — `LastSync: time.Now()` sets the sync time to manifest generation time, not the actual sync time from the lockfile.\n\nBoth require changes to the `Generate` function signature and Collection struct.\n\n## Implementation Steps\n\n### Step 1: Add Dir field to Collection struct\n\nIn `internal/manifest/manifest.go`, add a `Dir` field:\n\n```go\ntype Collection struct {\n    Name      string     `json:\"name\"`\n    Dir       string     `json:\"dir\"`\n    Type      string     `json:\"type\"`\n    Source    string     `json:\"source\"`\n    Path      string     `json:\"path,omitempty\"`\n    Ref       string     `json:\"ref,omitempty\"`\n    LastSync  time.Time  `json:\"last_sync\"`\n    FileCount int        `json:\"file_count\"`\n    TotalSize int64      `json:\"total_size\"`\n    Files     []FileInfo `json:\"files\"`\n}\n```\n\nThe `Dir` field stores the relative directory name under the output root (either `src.Out` or the source name). This is what commands use to resolve file paths.\n\n### Step 2: Update Generate function to accept lockfile\n\nIn `internal/manifest/generator.go`, change the function signature:\n\n```go\nfunc Generate(_ context.Context, cfg *config.Config, lock *lockfile.LockFile) error {\n```\n\nAdd import for `\"github.com/g5becks/dox/internal/lockfile\"`.\n\n### Step 3: Set Dir and LastSync in Generate\n\nIn the collection construction loop:\n\n```go\ndirName := sourceName\nif sourceCfg.Out != \"\" {\n    dirName = sourceCfg.Out\n}\n\ncollection := \u0026Collection{\n    Name:     sourceName,\n    Dir:      dirName,\n    Type:     sourceCfg.Type,\n    Source:   resolveSourceLocation(sourceCfg),\n    Path:     sourceCfg.Path,\n    Ref:      sourceCfg.Ref,\n    LastSync: resolveLastSync(lock, sourceName),\n}\n```\n\nAdd helper:\n```go\nfunc resolveLastSync(lock *lockfile.LockFile, sourceName string) time.Time {\n    if lock != nil {\n        if entry := lock.GetEntry(sourceName); entry != nil {\n            return entry.SyncedAt\n        }\n    }\n    return time.Now()\n}\n```\n\n### Step 4: Update sync.go caller\n\nIn `internal/sync/sync.go`, pass the lock to Generate:\n\n```go\n// Line ~151\nif genErr := manifest.Generate(ctx, cfg, lock); genErr != nil {\n```\n\n### Step 5: Update tests\n\n1. **generator_test.go** — Update all `manifest.Generate(context.Background(), cfg)` calls to pass `nil` as the lock parameter: `manifest.Generate(context.Background(), cfg, nil)`\n2. **integration_test.go** — Same update for all Generate calls\n3. **bench_test.go** — Same update\n4. Add a test that verifies Dir is set correctly when source has `Out` configured\n5. Add a test that verifies Dir defaults to source name when Out is empty\n\n### Step 6: Verify\n\n```bash\ngo build ./...\ngo test ./...\n```\n\n## Acceptance Criteria\n\n- [ ] Collection struct has `Dir string` field with `json:\"dir\"`\n- [ ] Generate accepts `*lockfile.LockFile` parameter\n- [ ] Dir is set to `src.Out` when configured, else source name\n- [ ] LastSync uses lockfile entry SyncedAt when available\n- [ ] All callers updated (sync.go, all tests)\n- [ ] New tests verify Dir and LastSync behavior\n- [ ] `go build ./...` succeeds\n- [ ] `go test ./...` passes\n\n## Commit\n\n```bash\ngit add internal/manifest/ internal/sync/sync.go\ngit commit -m \"fix: add Dir field to Collection and use lockfile timestamps in generator\"\n```","status":"closed","priority":1,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:40:34.852264-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T23:21:52.6503-05:00","closed_at":"2026-02-08T23:21:52.6503-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-ji0","depends_on_id":"dox-wym","type":"blocks","created_at":"2026-02-08T22:52:26.173016-05:00","created_by":"Takin Profit"},{"issue_id":"dox-ji0","depends_on_id":"dox-ub5","type":"blocks","created_at":"2026-02-08T22:52:26.837173-05:00","created_by":"Takin Profit"}]}
{"id":"dox-lfs","title":"Replace intToString with strconv.Itoa and remove redundant doc.go","description":"## Problem\n\nTwo related code quality issues in the query feature:\n\n1. **cmd/dox/cat.go:197-207** — Custom `intToString()` function reinvents `strconv.Itoa()` and does NOT handle negative numbers. If a negative offset or limit propagates, it will infinite-loop. This function is also used in `cmd/dox/files.go:209`.\n\n2. **internal/parser/doc.go** — Contains only a blank import of `github.com/gomarkdown/markdown`. This is redundant because `internal/parser/markdown.go` already imports `gomarkdown/markdown/ast` and `gomarkdown/markdown/parser`. The blank import adds an unnecessary build dependency at the package level.\n\n## Implementation Steps\n\n### Step 1: Replace intToString in cat.go\n\n1. Open `cmd/dox/cat.go`\n2. Add `\"strconv\"` to the import block\n3. Replace ALL calls to `intToString(...)` with `strconv.Itoa(...)`\n4. Delete the `intToString` function entirely (lines 197-207)\n\n### Step 2: Replace intToString in files.go\n\n1. Open `cmd/dox/files.go`\n2. Add `\"strconv\"` to the import block (if not already present)\n3. Replace ALL calls to `intToString(...)` with `strconv.Itoa(...)`\n4. Verify the function is no longer defined anywhere in `cmd/dox/`\n\n### Step 3: Delete redundant doc.go\n\n1. Delete the file `internal/parser/doc.go` entirely\n2. Verify `go build ./...` still succeeds (markdown.go provides the actual imports)\n\n### Step 4: Verify\n\n```bash\ngo build ./...\ngo test ./internal/parser/... ./cmd/dox/...\ngo vet ./...\n```\n\n## Acceptance Criteria\n\n- [ ] No `intToString` function exists anywhere in `cmd/dox/`\n- [ ] All former `intToString` calls use `strconv.Itoa`\n- [ ] `internal/parser/doc.go` is deleted\n- [ ] `go build ./...` succeeds\n- [ ] `go test ./...` passes\n- [ ] `go vet ./...` clean\n\n## Commit\n\n```bash\ngit add cmd/dox/cat.go cmd/dox/files.go\ngit rm internal/parser/doc.go\ngit commit -m \"fix: replace custom intToString with strconv.Itoa and remove redundant doc.go\"\n```","status":"closed","priority":1,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:35:15.602527-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T23:10:43.874956-05:00","closed_at":"2026-02-08T23:10:43.874956-05:00","close_reason":"Closed"}
{"id":"dox-m8y","title":"Run integration tests with real repos","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:29:07.769765-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T19:45:37.621959-05:00","closed_at":"2026-02-06T19:45:37.621959-05:00","close_reason":"Unable to run real integration tests in this environment: outbound DNS/network blocked for api.github.com and hono.dev."}
{"id":"dox-mrb","title":"Fix MDX parser multi-line import stripping","description":"## Problem\n\n**internal/parser/mdx.go:50-65** — The `stripMDXSyntax` function strips import and export lines one at a time, but does NOT handle multi-line imports:\n\n```tsx\nimport {\n  Component,\n  AnotherComponent\n} from './components'\n```\n\nOnly the `import {` line would be stripped, leaving broken content (`Component,`, `AnotherComponent`, `} from './components'`) for the markdown parser. This produces garbled headings/descriptions.\n\nSimilarly, multi-line export const declarations are not handled:\n```tsx\nexport const metadata = {\n  title: 'Test'\n}\n```\n\n## Implementation Steps\n\n### Step 1: Replace line-by-line stripping with state-aware approach\n\nIn `internal/parser/mdx.go`, replace the `stripMDXSyntax` function with one that tracks whether we are inside a multi-line import/export block:\n\n```go\nfunc stripMDXSyntax(content []byte) []byte {\n    lines := bytes.Split(content, []byte(\"\\n\"))\n    var cleaned [][]byte\n    inBlock := false\n    \n    for _, line := range lines {\n        if inBlock {\n            // Check if this line closes the block\n            trimmed := bytes.TrimSpace(line)\n            if bytes.HasPrefix(trimmed, []byte(\"}\")) || \n               bytes.HasSuffix(trimmed, []byte(\")\")) ||\n               (!bytes.ContainsAny(trimmed, \"{}()\") \u0026\u0026 bytes.Contains(trimmed, []byte(\"from \"))) {\n                inBlock = false\n            }\n            continue\n        }\n        \n        if importLineRegex.Match(line) {\n            // Check if this is a multi-line import (has { but no closing })\n            if bytes.Contains(line, []byte(\"{\")) \u0026\u0026 !bytes.Contains(line, []byte(\"}\")) {\n                inBlock = true\n            }\n            continue\n        }\n        if exportMetaRegex.Match(line) {\n            // Check if multi-line (has { but no closing })\n            if bytes.Contains(line, []byte(\"{\")) \u0026\u0026 !bytes.Contains(line, []byte(\"}\")) {\n                inBlock = true\n            }\n            continue\n        }\n        \n        cleaned = append(cleaned, line)\n    }\n    \n    return bytes.Join(cleaned, []byte(\"\\n\"))\n}\n```\n\nNote: This is a heuristic approach. The key insight is that import/export blocks that open a `{` on one line and close on another should be fully stripped. The exact implementation may need refinement — the important thing is that tests pass.\n\n### Step 2: Add tests for multi-line imports\n\nIn `internal/parser/mdx_test.go`, add test cases:\n\n```go\n{\n    name: \"with multi-line import\",\n    content: \"import {\\n  Component,\\n  Other\\n} from './components'\\n\\n# Title\\nContent.\",\n    wantDesc:     \"Title - Content.\",\n    wantHeadings: 1,\n},\n{\n    name: \"with multi-line export\",\n    content: \"export const meta = {\\n  title: 'Test'\\n}\\n\\n# Title\\nContent.\",\n    wantDesc:     \"Title - Content.\",\n    wantHeadings: 1,\n},\n```\n\n### Step 3: Verify\n\n```bash\ngo test ./internal/parser/... -run TestMDX -v\ngo test ./internal/parser/...\ngo build ./...\n```\n\n## Acceptance Criteria\n\n- [ ] Multi-line imports (with `{` on import line, `}` on later line) are fully stripped\n- [ ] Multi-line export const declarations are fully stripped\n- [ ] Single-line imports still work correctly (no regression)\n- [ ] New test cases pass\n- [ ] All existing MDX tests still pass\n- [ ] `go build ./...` succeeds\n- [ ] `go test ./...\\` passes\n\n## Commit\n\n```bash\ngit add internal/parser/mdx.go internal/parser/mdx_test.go\ngit commit -m \"fix: handle multi-line import/export stripping in MDX parser\"\n```","status":"open","priority":2,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:42:38.434972-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T22:42:38.434972-05:00","dependencies":[{"issue_id":"dox-mrb","depends_on_id":"dox-ub5","type":"blocks","created_at":"2026-02-08T22:52:27.320135-05:00","created_by":"Takin Profit"}]}
{"id":"dox-my9","title":"Implement CLI skeleton with urfave/cli v3","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:36.354118-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T16:50:30.238757-05:00","closed_at":"2026-02-06T16:50:30.238757-05:00","close_reason":"Closed"}
{"id":"dox-ncq","title":"Fix cat command: line_numbers config, trailing newline, path resolution","description":"## Problem\n\nThree bugs in `cmd/dox/cat.go`:\n\n### Bug 1: line_numbers config not consulted (line 139)\n```go\nshowLineNumbers := !cmd.Bool(\"no-line-numbers\")\n```\nThe `Display.LineNumbers` config setting is never read. The command always defaults to showing line numbers. The config value should be the base default, overridden only by `--no-line-numbers`.\n\n### Bug 2: Trailing newline off-by-one (line 122)\n```go\nlines := strings.Split(string(content), \"\\n\")\n```\nA file ending with `\\n` (standard) produces an empty trailing element. A 3-line file yields `[\"line1\", \"line2\", \"line3\", \"\"]`. Users see a phantom empty 4th line. The line count from `dox files` won't match what `dox cat` shows.\n\n### Bug 3: Path resolution ignores out config (line 112)\n```go\nfullPath := filepath.Join(cfg.Output, collectionName, filePath)\n```\nWhen a source has `out = \"custom-dir\"`, files live at `cfg.Output/custom-dir/...` but cat resolves to `cfg.Output/collectionName/...`. After task dox-ji0 adds `Collection.Dir`, cat should use it.\n\n## Prerequisites\n\n- **dox-lfs** must be completed first (`strconv.Itoa` replaces `intToString`)\n- **dox-ji0** must be completed first (`Collection.Dir` field exists)\n\n## Implementation Steps\n\n### Step 1: Fix line_numbers config\n\nIn `cmd/dox/cat.go`, update the `catAction` function. After loading the config, determine line numbers setting:\n\n```go\nshowLineNumbers := cfg.Display.LineNumbers\nif cmd.IsSet(\"no-line-numbers\") {\n    showLineNumbers = false\n}\n```\n\n### Step 2: Fix trailing newline\n\nAfter splitting content into lines, trim the trailing empty element:\n\n```go\nlines := strings.Split(string(content), \"\\n\")\n// Remove phantom trailing empty line from files ending with newline\nif len(lines) \u003e 0 \u0026\u0026 lines[len(lines)-1] == \"\" {\n    lines = lines[:len(lines)-1]\n}\n```\n\n### Step 3: Fix path resolution using Collection.Dir\n\nReplace the hardcoded path:\n```go\n// Before:\nfullPath := filepath.Join(cfg.Output, collectionName, filePath)\n\n// After:\nfullPath := filepath.Join(cfg.Output, collection.Dir, filePath)\n```\n\nThis uses the `Dir` field added by task dox-ji0, which correctly resolves to `src.Out` or the source name.\n\n### Step 4: Add tests\n\nSince cat.go is in the main package, test the individual logic pieces:\n\nAdd test verification by creating a test scenario in the integration tests or by testing with a real config that has `out` set. At minimum, verify:\n\n1. A file with trailing newline shows correct line count (not count+1)\n2. The path resolution uses Dir correctly\n\nFor the line_numbers config test, verify the config is respected by inspecting the behavior (this is better tested via a quick manual smoke test or by adding a testable helper).\n\n### Step 5: Verify\n\n```bash\ngo build ./...\ngo test ./...\ngo vet ./...\n```\n\n## Acceptance Criteria\n\n- [ ] Line numbers default comes from `cfg.Display.LineNumbers`\n- [ ] `--no-line-numbers` flag overrides config to disable line numbers\n- [ ] Trailing empty line from `strings.Split` is trimmed\n- [ ] Path resolution uses `collection.Dir` instead of `collectionName`\n- [ ] `go build ./...` succeeds\n- [ ] `go test ./...` passes\n\n## Commit\n\n```bash\ngit add cmd/dox/cat.go\ngit commit -m \"fix: cat command line_numbers config, trailing newline, and path resolution\"\n```","status":"closed","priority":1,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:47:54.364133-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T23:22:41.054624-05:00","closed_at":"2026-02-08T23:22:41.054624-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-ncq","depends_on_id":"dox-lfs","type":"blocks","created_at":"2026-02-08T22:58:13.902224-05:00","created_by":"Takin Profit"},{"issue_id":"dox-ncq","depends_on_id":"dox-ji0","type":"blocks","created_at":"2026-02-08T22:58:14.434633-05:00","created_by":"Takin Profit"}]}
{"id":"dox-nkg","title":"Write GitHub source tests","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:50.3469-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:29:54.866624-05:00","closed_at":"2026-02-06T18:29:54.866624-05:00","close_reason":"Closed"}
{"id":"dox-nyb","title":"Implement sync orchestrator","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:56.332371-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:42:45.461759-05:00","closed_at":"2026-02-06T18:42:45.461759-05:00","close_reason":"Closed"}
{"id":"dox-p7g","title":"Fix testdata doc-component.tsx to be realistic TSX","description":"## Problem\n\n**testdata/doc-component.tsx** is raw HTML tags without any JSX runtime, imports, or function exports:\n\n\\`\\`\\`html\n\u003ch1\u003eButton Component\u003c/h1\u003e\n\u003cp\u003eA reusable button component.\u003c/p\u003e\n\u003ch2\u003eProps\u003c/h2\u003e\n...\n\\`\\`\\`\n\nThis is not a valid TSX file. While it works for testing the regex extractor (which only looks for \\`\u003ch1\u003e\\`-\\`\u003ch6\u003e\\` tags), it does not represent a realistic TSX documentation component. The testdata should be representative of real-world files to ensure the parser handles actual use cases.\n\n## Implementation Steps\n\n### Step 1: Rewrite testdata/doc-component.tsx\n\nReplace the contents with a realistic TSX documentation component:\n\n\\`\\`\\`tsx\nimport React from 'react';\n\nexport default function ButtonDocs() {\n  return (\n    \u003cdiv className=\"docs\"\u003e\n      \u003ch1\u003eButton Component\u003c/h1\u003e\n      \u003cp\u003eA reusable button component for your application.\u003c/p\u003e\n\n      \u003ch2\u003eProps\u003c/h2\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ccode\u003evariant\u003c/code\u003e: Button style variant\u003c/li\u003e\n        \u003cli\u003e\u003ccode\u003eonClick\u003c/code\u003e: Click handler function\u003c/li\u003e\n      \u003c/ul\u003e\n\n      \u003ch2\u003eExamples\u003c/h2\u003e\n      \u003cpre\u003e\n        {\\`\u003cButton variant=\"primary\"\u003eClick me\u003c/Button\u003e\\`}\n      \u003c/pre\u003e\n    \u003c/div\u003e\n  );\n}\n\\`\\`\\`\n\n### Step 2: Verify the existing tests still pass\n\nThe parser tests reference this file. Make sure the file still has \u003e= 2 JSX headings so it is detected as a documentation component.\n\n\\`\\`\\`bash\ngo test ./internal/parser/... -run TestCrossParser -v\ngo test ./internal/parser/... -run TestTSXDoc -v\n\\`\\`\\`\n\n### Step 3: Verify\n\n\\`\\`\\`bash\ngo test ./...\ngo build ./...\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] \\`testdata/doc-component.tsx\\` contains valid TSX with import, function export, and JSX headings\n- [ ] File has \u003e= 2 \\`\u003ch1\u003e\\`-\\`\u003ch6\u003e\\` tags (detected as documentation component)\n- [ ] All parser tests pass\n- [ ] All integration tests pass\n\n## Commit\n\n\\`\\`\\`bash\ngit add testdata/doc-component.tsx\ngit commit -m \"fix: make testdata doc-component.tsx a realistic TSX documentation component\"\n\\`\\`\\`","status":"open","priority":3,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:47:15.392794-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T22:47:15.392794-05:00","dependencies":[{"issue_id":"dox-p7g","depends_on_id":"dox-ub5","type":"blocks","created_at":"2026-02-08T22:52:28.918699-05:00","created_by":"Takin Profit"}]}
{"id":"dox-qsi","title":"Implement dry-run mode","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:29:03.200116-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T19:32:53.508276-05:00","closed_at":"2026-02-06T19:32:53.508276-05:00","close_reason":"Closed"}
{"id":"dox-rh2","title":"Add integration tests and benchmarks for query feature","description":"## Overview\nAdd end-to-end integration tests that verify the full workflow (sync → manifest → query) and performance benchmarks.\n\n## Dependencies\n- All query commands and manifest generation must be implemented\n\n## Files to Create\n\n### `internal/manifest/bench_test.go`\nBenchmarks:\n- BenchmarkManifestLoad100Files (target: \u003c10ms)\n- BenchmarkManifestLoad1000Files (target: \u003c100ms)\n- BenchmarkManifestGenerate100Files (target: \u003c1s)\n\nCreate test fixtures programmatically (generate N sample .md files in temp dirs).\n\n### `internal/manifest/integration_test.go`\nIntegration tests:\n- Full workflow: create config, create sample files, generate manifest, load and query\n- Verify manifest structure matches expectations\n- Verify file metadata (size, lines, description, outline)\n- Verify each file type produces correct results\n- Test with mixed file types in one collection\n- Test empty collection handling\n- Test manifest round-trip (generate → save → load → verify)\n\n### `internal/parser/integration_test.go`\nCross-parser tests:\n- Parse same content as .md and .mdx, verify similar results\n- Parse TSX documentation component, verify headings match\n- Parse TSX code component, verify exports match\n- Test all parsers with empty files\n- Test all parsers with binary content (should be caught by IsBinary)\n\n## Test Fixtures\nCreate a `testdata/` directory with representative files:\n- `testdata/sample.md` - markdown with headings\n- `testdata/sample.mdx` - MDX with frontmatter\n- `testdata/sample.txt` - plain text\n- `testdata/doc-component.tsx` - TSX documentation component\n- `testdata/code-component.tsx` - TSX code component\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes all new tests\n- Benchmarks run and produce results\n- All file types covered in integration tests\n\n## Commit\n```bash\ngit add internal/manifest/bench_test.go internal/manifest/integration_test.go internal/parser/integration_test.go testdata/\ngit commit -m \"test: add integration tests and benchmarks for query feature\"\n```","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:28:12.0809-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T22:11:47.082668-05:00","closed_at":"2026-02-08T22:11:47.082668-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-rh2","depends_on_id":"dox-32p","type":"blocks","created_at":"2026-02-08T19:37:19.050971-05:00","created_by":"Takin Profit"},{"issue_id":"dox-rh2","depends_on_id":"dox-xbq","type":"blocks","created_at":"2026-02-08T19:37:22.4829-05:00","created_by":"Takin Profit"},{"issue_id":"dox-rh2","depends_on_id":"dox-asf","type":"blocks","created_at":"2026-02-08T19:37:25.025441-05:00","created_by":"Takin Profit"},{"issue_id":"dox-rh2","depends_on_id":"dox-ax0","type":"blocks","created_at":"2026-02-08T19:37:27.658599-05:00","created_by":"Takin Profit"},{"issue_id":"dox-rh2","depends_on_id":"dox-wek","type":"blocks","created_at":"2026-02-08T19:37:30.953881-05:00","created_by":"Takin Profit"}]}
{"id":"dox-ryb","title":"Wire list command","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:58.572905-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:50:59.162374-05:00","closed_at":"2026-02-06T18:50:59.162374-05:00","close_reason":"Closed"}
{"id":"dox-s9e","title":"Fix TSX heading line numbers for duplicate headings","description":"## Problem\n\n**internal/parser/typescript.go:79** — When extracting JSX headings, `extractJSXHeadings` uses `bytes.Index(content, match[0])` to find line numbers. `bytes.Index` returns the position of the FIRST occurrence. If two headings have identical text (e.g., two `\u003ch2\u003eExample\u003c/h2\u003e` tags), both report the line number of the first one.\n\n```go\nlineNum := lineNumberAt(content, bytes.Index(content, match[0]))\n```\n\nThe same bug exists in `extractExports` at line 97:\n```go\nlineNum := lineNumberAt(content, bytes.Index(content, match[0]))\n```\n\n## Implementation Steps\n\n### Step 1: Use FindAllSubmatchIndex instead of FindAllSubmatch\n\nThe fix is to use the index-returning variant of the regex API, which provides the exact byte offset of each match.\n\nIn `internal/parser/typescript.go`, rewrite `extractJSXHeadings`:\n\n```go\nfunc extractJSXHeadings(content []byte) []Heading {\n    indices := jsxHeadingRegex.FindAllSubmatchIndex(content, -1)\n    headings := make([]Heading, 0, len(indices))\n    \n    for _, idx := range indices {\n        // idx[0]:idx[1] = full match\n        // idx[2]:idx[3] = capture group 1 (level digit)\n        // idx[4]:idx[5] = capture group 2 (heading text)\n        level := int(content[idx[2]] - '0')\n        text := string(content[idx[4]:idx[5]])\n        text = jsxTagStripper.ReplaceAllString(text, \"\")\n        text = strings.TrimSpace(text)\n        \n        if text == \"\" {\n            continue\n        }\n        \n        lineNum := lineNumberAt(content, idx[0])\n        headings = append(headings, Heading{\n            Level: level,\n            Text:  text,\n            Line:  lineNum,\n        })\n    }\n    \n    return headings\n}\n```\n\n### Step 2: Fix extractExports the same way\n\n```go\nfunc extractExports(content []byte) []Export {\n    indices := exportRegex.FindAllSubmatchIndex(content, -1)\n    exports := make([]Export, 0, len(indices))\n    \n    for _, idx := range indices {\n        // idx[2]:idx[3] = capture group 1 (export type)\n        // idx[4]:idx[5] = capture group 2 (name)\n        exportType := string(content[idx[2]:idx[3]])\n        name := string(content[idx[4]:idx[5]])\n        lineNum := lineNumberAt(content, idx[0])\n        \n        exports = append(exports, Export{\n            Type: exportType,\n            Name: name,\n            Line: lineNum,\n        })\n    }\n    \n    return exports\n}\n```\n\n### Step 3: Add test for duplicate headings\n\nIn `internal/parser/typescript_test.go`, add a test case:\n\n```go\n{\n    name: \"duplicate heading text has correct line numbers\",\n    content: `\u003ch2\u003eExample\u003c/h2\u003e\n\u003cp\u003eFirst example\u003c/p\u003e\n\u003ch2\u003eExample\u003c/h2\u003e\n\u003cp\u003eSecond example\u003c/p\u003e`,\n    wantComponentType: parser.ComponentTypeDocumentation,\n    wantOutlineType:   parser.OutlineTypeHeadings,\n    wantHeadings:      2,\n    wantExports:       0,\n},\n```\n\nThen add a specific test that checks line numbers:\n```go\nfunc TestTypeScriptParser_DuplicateHeadingLineNumbers(t *testing.T) {\n    p := parser.NewTypeScriptParser()\n    content := \"\u003ch1\u003eTitle\u003c/h1\u003e\\n\u003cp\u003etext\u003c/p\u003e\\n\u003ch2\u003eSection\u003c/h2\u003e\\n\u003cp\u003etext\u003c/p\u003e\\n\u003ch2\u003eSection\u003c/h2\u003e\"\n    \n    result, err := p.Parse(\"test.tsx\", []byte(content))\n    if err != nil {\n        t.Fatalf(\"Parse() error = %v\", err)\n    }\n    \n    if len(result.Outline.Headings) != 3 {\n        t.Fatalf(\"expected 3 headings, got %d\", len(result.Outline.Headings))\n    }\n    \n    // The two \"Section\" headings should have different line numbers\n    h2 := result.Outline.Headings[1]\n    h3 := result.Outline.Headings[2]\n    if h2.Line == h3.Line {\n        t.Errorf(\"duplicate headings should have different line numbers, both got line %d\", h2.Line)\n    }\n    if h3.Line != 5 {\n        t.Errorf(\"third heading line = %d, want 5\", h3.Line)\n    }\n}\n```\n\n### Step 4: Add test for duplicate exports\n\n```go\nfunc TestTypeScriptParser_DuplicateExportLineNumbers(t *testing.T) {\n    p := parser.NewTypeScriptParser()\n    content := \"export const foo = 1\\nexport const bar = 2\\nexport const foo = 3\"\n    \n    result, err := p.Parse(\"test.ts\", []byte(content))\n    if err != nil {\n        t.Fatalf(\"Parse() error = %v\", err)\n    }\n    \n    // Should have 3 exports with different line numbers\n    if len(result.Outline.Exports) != 3 {\n        t.Fatalf(\"expected 3 exports, got %d\", len(result.Outline.Exports))\n    }\n    \n    if result.Outline.Exports[2].Line != 3 {\n        t.Errorf(\"third export line = %d, want 3\", result.Outline.Exports[2].Line)\n    }\n}\n```\n\n### Step 5: Verify\n\n```bash\ngo test ./internal/parser/... -run TestTypeScript -v\ngo test ./...\ngo build ./...\n```\n\n## Acceptance Criteria\n\n- [ ] `extractJSXHeadings` uses `FindAllSubmatchIndex` (not `FindAllSubmatch` + `bytes.Index`)\n- [ ] `extractExports` uses `FindAllSubmatchIndex` (not `FindAllSubmatch` + `bytes.Index`)\n- [ ] Duplicate headings report correct (different) line numbers\n- [ ] Duplicate exports report correct (different) line numbers\n- [ ] New tests verify line number correctness\n- [ ] All existing TypeScript parser tests still pass\n- [ ] `go build ./...` succeeds\n- [ ] `go test ./...` passes\n\n## Commit\n\n```bash\ngit add internal/parser/typescript.go internal/parser/typescript_test.go\ngit commit -m \"fix: use FindAllSubmatchIndex for correct TSX heading/export line numbers\"\n```","status":"open","priority":2,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:46:32.195312-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T22:46:32.195312-05:00","dependencies":[{"issue_id":"dox-s9e","depends_on_id":"dox-ub5","type":"blocks","created_at":"2026-02-08T22:52:27.856074-05:00","created_by":"Takin Profit"}]}
{"id":"dox-t7g","title":"Fix naming inconsistencies (llxt → dox)","description":"Update Taskfile.yml and .golangci.yml to replace all llxt references with dox.\n\nFiles to modify:\n- Taskfile.yml: Change BINARY_NAME from llxt to dox, update ./cmd/llxt to ./cmd/dox\n- .golangci.yml: Change local-prefixes from github.com/g5becks/llxt to github.com/g5becks/dox\n\nAcceptance criteria:\n- task lint passes with no errors\n- All references to llxt are replaced with dox in both files\n- Grep search for 'llxt' returns no results in these files\n\nCommit:\ngit add Taskfile.yml .golangci.yml\ngit commit -m \"chore: rename llxt to dox in build configs\"","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:04.259376-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T15:40:30.548741-05:00","closed_at":"2026-02-06T15:40:30.548741-05:00","close_reason":"Closed"}
{"id":"dox-tyu","title":"Fix integration test patterns: constructors and struct init","description":"## Problem\n\n**internal/parser/integration_test.go:52-57** — Tests create parser structs directly instead of using constructors:\n\n\\`\\`\\`go\nparsers := []parser.Parser{\n    \u0026parser.MarkdownParser{},\n    \u0026parser.MDXParser{},\n    \u0026parser.TextParser{},\n    \u0026parser.TypeScriptParser{},\n}\n\\`\\`\\`\n\nThis bypasses \\`NewMarkdownParser()\\`, \\`NewMDXParser()\\`, etc. If constructor logic is added later (e.g., default options, initialization), these tests will silently use uninitialized parsers.\n\nThe MDXParser is particularly affected since \\`NewMDXParser()\\` initializes the internal \\`md\\` field:\n\\`\\`\\`go\nfunc NewMDXParser() *MDXParser {\n    return \u0026MDXParser{md: NewMarkdownParser()}\n}\n\\`\\`\\`\n\nDirect construction with \\`\u0026parser.MDXParser{}\\` leaves \\`md\\` as nil, which would panic if the integration test ever exercises MDX parsing deeply enough.\n\n## Prerequisites\n\n- **dox-8zf** should be completed (nilerr fix adds Skipped field)\n- **dox-ji0** should be completed (Dir field + lockfile timestamps)\n\n## Implementation Steps\n\n### Step 1: Update integration_test.go constructor usage\n\nIn \\`internal/parser/integration_test.go\\`, replace ALL direct struct initialization with constructor calls:\n\n**Line 52-57** (TestCrossParserIntegration):\n\\`\\`\\`go\nparsers := []parser.Parser{\n    parser.NewMarkdownParser(),\n    parser.NewMDXParser(),\n    parser.NewTextParser(),\n    parser.NewTypeScriptParser(),\n}\n\\`\\`\\`\n\n**Line 104** (TestAllParsersWithEmptyFiles):\n\\`\\`\\`go\nparsers := []struct {\n    name   string\n    parser parser.Parser\n    path   string\n}{\n    {\"markdown\", parser.NewMarkdownParser(), \"empty.md\"},\n    {\"mdx\", parser.NewMDXParser(), \"empty.mdx\"},\n    {\"text\", parser.NewTextParser(), \"empty.txt\"},\n    {\"typescript\", parser.NewTypeScriptParser(), \"empty.tsx\"},\n}\n\\`\\`\\`\n\n**Lines 138-139** (TestMarkdownVsMDXSimilarity):\n\\`\\`\\`go\nmdParser := parser.NewMarkdownParser()\nmdxParser := parser.NewMDXParser()\n\\`\\`\\`\n\n**Line 174** (TestTSXDocVsCodeComponent):\n\\`\\`\\`go\ntsParser := parser.NewTypeScriptParser()\n\\`\\`\\`\n\n**Lines 208-213** (TestParserRoundTrip):\n\\`\\`\\`go\nparsers := []parser.Parser{\n    parser.NewMarkdownParser(),\n    parser.NewMDXParser(),\n    parser.NewTextParser(),\n    parser.NewTypeScriptParser(),\n}\n\\`\\`\\`\n\n### Step 2: Verify\n\n\\`\\`\\`bash\ngo test ./internal/parser/... -v\ngo build ./...\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] No direct struct initialization (\\`\u0026parser.XxxParser{}\\`) in test files\n- [ ] All tests use \\`parser.NewXxxParser()\\` constructors\n- [ ] All tests pass\n- [ ] \\`go build ./...\\` succeeds\n\n## Commit\n\n\\`\\`\\`bash\ngit add internal/parser/integration_test.go\ngit commit -m \"fix: use parser constructors in integration tests instead of direct struct init\"\n\\`\\`\\`","status":"open","priority":3,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:48:25.291334-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T22:48:25.291334-05:00","dependencies":[{"issue_id":"dox-tyu","depends_on_id":"dox-8zf","type":"blocks","created_at":"2026-02-08T22:58:15.150849-05:00","created_by":"Takin Profit"},{"issue_id":"dox-tyu","depends_on_id":"dox-ji0","type":"blocks","created_at":"2026-02-08T22:58:15.690537-05:00","created_by":"Takin Profit"}]}
{"id":"dox-u78","title":"Move formatSize to shared cmd helpers file","description":"## Problem\n\n**cmd/dox/outline.go:139-150** — The `formatSize()` function is defined in `outline.go` but used by `collections.go` (line 124) and `files.go` (line 224). If someone removes the outline command, the other commands break. The function belongs in a shared utility file.\n\nSimilarly, `formatTime()` is defined in `collections.go:132-137` but used by `files.go:228`. Both helpers should live in a shared location.\n\n## Implementation Steps\n\n### Step 1: Create shared helpers file\n\n1. Create `cmd/dox/helpers.go` with `package main`\n2. Move `formatSize()` from `cmd/dox/outline.go` (lines 139-150) into it\n3. Move `formatTime()` from `cmd/dox/collections.go` (lines 132-137) into it\n\n### Step 2: Remove from original files\n\n1. Delete `formatSize` from `cmd/dox/outline.go`\n2. Delete `formatTime` from `cmd/dox/collections.go`\n3. Verify no duplicate definitions exist\n\n### Step 3: Verify imports\n\nNo import changes should be needed since these functions use only `fmt` and `time` which are already imported in their callers. The new `helpers.go` file needs:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n```\n\n### Step 4: Verify\n\n```bash\ngo build ./...\ngo test ./...\ngo vet ./...\n```\n\n## Acceptance Criteria\n\n- [ ] `cmd/dox/helpers.go` exists with `formatSize` and `formatTime`\n- [ ] `formatSize` is NOT in `cmd/dox/outline.go`\n- [ ] `formatTime` is NOT in `cmd/dox/collections.go`\n- [ ] No duplicate function definitions\n- [ ] `go build ./...` succeeds\n- [ ] `go test ./...` passes\n\n## Commit\n\n```bash\ngit add cmd/dox/helpers.go cmd/dox/outline.go cmd/dox/collections.go\ngit commit -m \"refactor: move formatSize and formatTime to shared cmd helpers file\"\n```","status":"closed","priority":2,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:35:57.400904-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T23:13:44.013839-05:00","closed_at":"2026-02-08T23:13:44.013839-05:00","close_reason":"Closed"}
{"id":"dox-ub5","title":"Fix all linter formatting and modernization issues","description":"## Problem\n\ngolangci-lint reports 20+ issues across multiple categories. These must all be fixed for a clean lint pass.\n\n### goimports (8 files) — Import grouping not formatted correctly:\n- cmd/dox/cat.go:10\n- cmd/dox/collections.go:10\n- cmd/dox/files.go:10\n- cmd/dox/outline.go:9\n- internal/manifest/generator.go:8\n- internal/manifest/integration_test.go:26\n- internal/manifest/manifest.go:10\n- internal/parser/integration_test.go:15\n\n### golines (3 files) — Lines too long:\n- cmd/dox/files.go:209\n- internal/config/config_test.go:446\n- internal/config/types.go:92\n\n### intrange (4 locations) — Use Go 1.22+ integer range:\n- internal/manifest/bench_test.go:25, 44, 60, 75\n\n### modernize (3 locations) — Use SplitSeq for ranging:\n- internal/parser/text.go:34 — bytes.Split → bytes.SplitSeq (or iter-based)\n- internal/parser/typescript.go:134 — strings.Split → strings.SplitSeq\n- internal/parser/utils.go:79 — bytes.Split → bytes.SplitSeq\n\n### govet shadow (1 location):\n- internal/manifest/integration_test.go:134 — declaration of \"err\" shadows\n\n## Implementation Steps\n\n### Step 1: Fix goimports\n\nRun goimports on all 8 files. The Go convention is three groups separated by blank lines:\n1. Standard library\n2. Third-party packages  \n3. Local packages\n\n```bash\ngoimports -w cmd/dox/cat.go cmd/dox/collections.go cmd/dox/files.go cmd/dox/outline.go\ngoimports -w internal/manifest/generator.go internal/manifest/integration_test.go internal/manifest/manifest.go\ngoimports -w internal/parser/integration_test.go\n```\n\n### Step 2: Fix golines\n\nFor `cmd/dox/files.go:209`, break the long string concatenation:\n```go\nmsg := \"\\n(showing \" + strconv.Itoa(len(files)) + \" of \" + strconv.Itoa(total) + \" files, use --all to show all)\\n\"\n_, _ = os.Stdout.WriteString(msg)\n```\nNOTE: This line may already use `strconv.Itoa` if task dox-lfs was completed first. If it still uses `intToString`, break the line regardless.\n\nFor `internal/config/config_test.go:446`, break onto multiple lines.\n\nFor `internal/config/types.go:92`, remove extra alignment spaces in the struct tag:\n```go\nFormat string `koanf:\"format\" validate:\"omitempty,oneof=table json csv\"`\n```\n\n### Step 3: Fix intrange (bench_test.go)\n\nReplace `for i := 0; i \u003c b.N; i++` with `for range b.N` (4 locations in internal/manifest/bench_test.go).\n\nReplace `for i := 0; i \u003c count; i++` with `for i := range count` (line 75, keep `i` since it is used in the loop body).\n\n### Step 4: Fix modernize — SplitSeq\n\n**internal/parser/text.go:34** — The `extractFirstLine` function uses `bytes.Split` then iterates. Replace with `bytes.SplitSeq`:\n```go\nfor line := range bytes.SplitSeq(content, []byte(\"\\n\")) {\n    trimmed := strings.TrimSpace(string(line))\n    if trimmed != \"\" {\n        return trimmed\n    }\n}\n```\nNOTE: `bytes.SplitSeq` returns an `iter.Seq[[]byte]`. Make sure to import `bytes` (already imported) and verify Go version supports it (Go 1.24+). If the project Go version is lower, use a `//nolint:modernize` comment instead.\n\n**internal/parser/typescript.go:134** — Same pattern with `strings.Split`.\n\n**internal/parser/utils.go:79** — Same pattern with `bytes.Split` in `StripFrontmatter`.\n\n### Step 5: Fix govet shadow\n\n**internal/manifest/integration_test.go:134** — Rename the inner `err` variable:\n```go\nif saveErr := m1.Save(doxDir); saveErr != nil {\n    t.Fatalf(\"save failed: %v\", saveErr)\n}\n```\n\n### Step 6: Verify\n\n```bash\ngolangci-lint run ./...\ngo test ./...\n```\n\nThe only remaining lint warnings should be the pre-existing gocognit issues (Config.Validate, sync.Run, and test functions).\n\n## Acceptance Criteria\n\n- [ ] `golangci-lint run ./...` reports ONLY pre-existing gocognit warnings (no goimports, golines, intrange, modernize, govet, nilerr, or revive issues)\n- [ ] `go build ./...` succeeds\n- [ ] `go test ./...` passes\n- [ ] All import groups follow Go convention (stdlib / third-party / local)\n\n## Commit\n\n```bash\ngit add .\ngit commit -m \"fix: resolve all linter formatting and modernization issues\"\n```","status":"closed","priority":1,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:39:02.256803-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T23:10:43.877626-05:00","closed_at":"2026-02-08T23:10:43.877626-05:00","close_reason":"Closed"}
{"id":"dox-ulc","title":"Wire init command","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:29:00.980601-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:55:28.007686-05:00","closed_at":"2026-02-06T18:55:28.007686-05:00","close_reason":"Closed"}
{"id":"dox-veo","title":"Add .dox/ to .gitignore and create LICENSE","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:31.825687-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T15:43:32.85771-05:00","closed_at":"2026-02-06T15:43:32.85771-05:00","close_reason":"Closed"}
{"id":"dox-w7u","title":"Fix README documentation to match actual CLI flags and config","description":"## Problem\n\n**README.md** — The Query Documentation section contains multiple inaccuracies. CLI flags, field names, and config keys shown in the README do not match the actual implementation. An AI agent or user following the README will get errors.\n\n### Specific mismatches:\n\n1. **Cat flags wrong**: README shows `--start 10 --end 50` and `--page 2 --page-size 20` — actual flags are `--offset` and `--limit`\n2. **Files fields wrong**: README shows `--fields path,description,headings` — actual valid fields are: `path`, `type`, `lines`, `size`, `description`, `modified`\n3. **Config keys wrong**: README shows `limit`, `desc_length`, `show_line_numbers`, `page_size` — actual config keys are: `default_limit`, `description_length`, `line_numbers` (no `page_size`)\n4. **Missing --all flag**: Not mentioned for `dox files`\n5. **Missing --json flag**: Not shown as available on all commands\n6. **Collections format flag**: README shows `--format json` and `--format csv` but the collections command only has `--json` flag (no `--format` flag)\n\n## Prerequisites\n\n- **dox-ncq** must be completed (cat fixes finalized, so we document the final behavior)\n\n## Implementation Steps\n\n### Step 1: Rewrite the Query Documentation section in README.md\n\nFind the section starting with `## Query Documentation` and rewrite it to match the actual CLI. Reference the actual command definitions in:\n- `cmd/dox/cat.go` — newCatCommand()\n- `cmd/dox/collections.go` — newCollectionsCommand()\n- `cmd/dox/files.go` — newFilesCommand()\n- `cmd/dox/outline.go` — newOutlineCommand()\n\n### Corrected Quick Start:\n```bash\ndox sync                                    # Sync and generate manifest\ndox collections                             # List all collections\ndox files goreleaser                        # List files in a collection\ndox cat goreleaser docs/install.md          # Read a file with line numbers\ndox outline goreleaser docs/install.md      # Show document structure\n```\n\n### Corrected Collections:\n```bash\ndox collections                   # Table output\ndox collections --json            # JSON output\ndox collections --limit 5         # Limit results\n```\n\n### Corrected Files:\n```bash\ndox files goreleaser                            # Default table output\ndox files goreleaser --json                     # JSON output\ndox files goreleaser --format csv               # CSV output\ndox files goreleaser --fields path,type,size    # Custom fields\ndox files goreleaser --limit 10                 # Limit results\ndox files goreleaser --all                      # Show all files (no limit)\ndox files goreleaser --desc-length 100          # Shorter descriptions\n```\n\nAvailable fields: `path`, `type`, `lines`, `size`, `description`, `modified`\n\n### Corrected Cat:\n```bash\ndox cat goreleaser docs/install.md                  # Show full file\ndox cat goreleaser docs/install.md --offset 10      # Start at line 10\ndox cat goreleaser docs/install.md --limit 20       # Show 20 lines\ndox cat goreleaser docs/install.md --no-line-numbers  # Without line numbers\ndox cat goreleaser docs/install.md --json           # JSON with metadata\n```\n\n### Corrected Config:\n```toml\n[display]\ndefault_limit = 50            # Default result limit for dox files\ndescription_length = 200      # Max description length\nline_numbers = true           # Show line numbers in dox cat\nformat = \"table\"              # Default format: table, json, csv\nlist_fields = [\"path\", \"type\", \"lines\", \"size\", \"description\"]\n```\n\n### Step 2: Verify by cross-referencing\n\nFor EACH command example in the README, verify the flags exist in the corresponding `newXxxCommand()` function. Do NOT document flags that do not exist.\n\n### Step 3: Verify\n\n```bash\ngo build ./...  # Ensure nothing broke\n```\n\n## Acceptance Criteria\n\n- [ ] Every CLI flag shown in README exists in the actual command definition\n- [ ] Every config key shown in README matches the actual struct tags in `config.Display`\n- [ ] Available fields list matches `getFieldValue` switch cases in files.go\n- [ ] No references to non-existent flags (`--start`, `--end`, `--page`, `--page-size`)\n- [ ] Collections command correctly shows `--json` (not `--format`)\n- [ ] AI Agent Integration example uses only valid flags\n- [ ] Troubleshooting section is accurate\n\n## Commit\n\n```bash\ngit add README.md\ngit commit -m \"docs: fix README query documentation to match actual CLI flags and config\"\n```","status":"closed","priority":1,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:49:09.30737-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T23:26:21.244548-05:00","closed_at":"2026-02-08T23:26:21.244548-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-w7u","depends_on_id":"dox-ncq","type":"blocks","created_at":"2026-02-08T22:58:16.152455-05:00","created_by":"Takin Profit"}]}
{"id":"dox-wek","title":"Integrate manifest generation into sync","description":"## Overview\nHook manifest generation into the sync pipeline so that `dox sync` automatically generates/updates `manifest.json` after syncing files.\n\n## Dependencies\n- Manifest generator must be implemented\n\n## Files to Modify\n\n### `internal/sync/sync.go`\nAdd manifest generation after lock.Save():\n\n```go\nimport \"github.com/g5becks/dox/internal/manifest\"\n\n// In Run() function, after the lock.Save() block (~line 155):\n\n// Save lock file\nif !opts.DryRun {\n    if saveErr := lock.Save(outputDir); saveErr != nil {\n        return nil, saveErr\n    }\n\n    // Generate manifest (non-fatal)\n    if genErr := manifest.Generate(ctx, cfg); genErr != nil {\n        // Log warning but don't fail the sync\n        if opts.OnEvent != nil {\n            opts.OnEvent(Event{\n                Kind: EventManifestError,\n                Err:  genErr,\n            })\n        }\n    }\n}\n```\n\nAdd new event kind:\n```go\n// In the EventKind constants:\nEventManifestError EventKind = \"manifest_error\"\n```\n\n### `internal/ui/sync.go`\nHandle the new event kind in SyncPrinter.HandleEvent:\n```go\ncase doxsync.EventManifestError:\n    fmt.Fprintf(p.w, \"%s manifest generation failed: %v\\n\",\n        p.s.warn.Sprint(\"⚠\"),\n        e.Err,\n    )\n```\n\n### Test Updates\n- Add test that verifies manifest.json is created after sync\n- Add test that sync succeeds even when manifest generation fails (non-fatal)\n- Verify manifest is NOT generated during dry-run\n\n## Key Decisions\n- Manifest generation is NON-FATAL: if it fails, sync still succeeds\n- Manifest is NOT generated during dry-run\n- Manifest is always fully regenerated (not incremental)\n- The event system is used to communicate manifest errors to the UI\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes including new and existing tests\n- Running `dox sync` on a configured project creates .dox/manifest.json\n- Dry-run does NOT create manifest.json\n\n## Commit\n```bash\ngit add internal/sync/sync.go internal/ui/sync.go\ngit commit -m \"feat: integrate manifest generation into sync pipeline\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:24:14.551711-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T21:18:27.789078-05:00","closed_at":"2026-02-08T21:18:27.789078-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-wek","depends_on_id":"dox-zzv","type":"blocks","created_at":"2026-02-08T19:36:35.134783-05:00","created_by":"Takin Profit"}]}
{"id":"dox-wym","title":"Rename manifest.ManifestPath to manifest.Path to fix stutter","description":"## Problem\n\n**internal/manifest/manifest.go:155** — The exported function `ManifestPath` stutters when called as `manifest.ManifestPath()`. The revive linter flags this:\n\n```\nfunc name will be used as manifest.ManifestPath by other packages, and that stutters; consider calling this Path\n```\n\nThis violates Go naming conventions (Effective Go: package-qualified names should read naturally).\n\n## Implementation Steps\n\n### Step 1: Rename the function\n\n1. Open `internal/manifest/manifest.go`\n2. Rename `func ManifestPath(outputDir string) string` → `func Path(outputDir string) string`\n\n### Step 2: Update all callers\n\nSearch for all references to `manifest.ManifestPath` and `ManifestPath` and update them:\n\n1. **internal/manifest/manifest.go** — Internal call in `Save()` at line 114: `ManifestPath(outputDir)` → `Path(outputDir)`\n2. **internal/manifest/manifest.go** — Internal call in `Load()` at line 58: `ManifestPath(outputDir)` → `Path(outputDir)`  \n3. **internal/manifest/manifest_test.go** — Test references: `manifest.ManifestPath(dir)` → `manifest.Path(dir)`\n\nUse grep to find ALL references:\n```bash\ngrep -rn \"ManifestPath\" --include=\"*.go\"\n```\n\n### Step 3: Verify\n\n```bash\ngo build ./...\ngo test ./internal/manifest/...\ngo vet ./...\n```\n\n## Acceptance Criteria\n\n- [ ] Function is renamed from `ManifestPath` to `Path`\n- [ ] All callers updated (internal and test)\n- [ ] No references to `ManifestPath` remain (grep confirms)\n- [ ] `go build ./...` succeeds\n- [ ] `go test ./...` passes\n- [ ] revive linter no longer reports stutter\n\n## Commit\n\n```bash\ngit add internal/manifest/\ngit commit -m \"fix: rename manifest.ManifestPath to manifest.Path to fix stutter\"\n```","status":"closed","priority":2,"issue_type":"bug","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T22:35:37.126323-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T23:12:24.453429-05:00","closed_at":"2026-02-08T23:12:24.453429-05:00","close_reason":"Closed"}
{"id":"dox-xbq","title":"Implement dox files command","description":"## Overview\nImplement the `dox files \u003ccollection\u003e` CLI command that lists files in a collection with metadata (path, type, lines, size, description).\n\n## Dependencies\n- Manifest types and persistence must exist\n- Display config must exist\n- Format helpers from collections command must exist\n\n## Files to Create/Modify\n\n### `cmd/dox/files.go` (NEW)\n```go\npackage main\n\nfunc newFilesCommand() *cli.Command {\n    return \u0026cli.Command{\n        Name:      \"files\",\n        Usage:     \"List files in a collection\",\n        ArgsUsage: \"\u003ccollection\u003e\",\n        Flags: []cli.Flag{\n            \u0026cli.BoolFlag{Name: \"json\", Usage: \"Output as JSON\"},\n            \u0026cli.IntFlag{Name: \"limit\", Value: 0, Usage: \"Show first N files (0 = use config default)\"},\n            \u0026cli.BoolFlag{Name: \"all\", Usage: \"Show all files (no limit)\"},\n            \u0026cli.StringFlag{Name: \"format\", Usage: \"Output format: table, json, csv\"},\n            \u0026cli.StringFlag{Name: \"fields\", Usage: \"Comma-separated fields: path,type,lines,size,description,modified\"},\n            \u0026cli.IntFlag{Name: \"desc-length\", Value: 0, Usage: \"Max description length (0 = use config default)\"},\n        },\n        Action: filesAction,\n    }\n}\n\nfunc filesAction(ctx context.Context, cmd *cli.Command) error {\n    // 1. Validate: require exactly 1 positional arg (collection name)\n    // 2. Load config and manifest\n    // 3. Look up collection by name - error if not found (list available)\n    // 4. Resolve display settings: CLI flags \u003e config \u003e defaults\n    //    - limit: --all overrides to 0, --limit overrides config, else config default\n    //    - format: --json sets \"json\", --format overrides config\n    //    - fields: --fields overrides config, else config default\n    //    - desc-length: --desc-length overrides config\n    // 5. Apply limit to file list\n    // 6. Render based on format:\n    //    - \"table\": go-pretty table with selected fields\n    //    - \"json\": JSON array to stdout\n    //    - \"csv\": CSV with header row\n    // 7. If limited, show footer: \"(showing N of M files, use --all to show all)\"\n}\n```\n\n**Field handling:**\n- `path`: file path relative to collection\n- `type`: file extension type (md, mdx, txt, tsx, ts)\n- `lines`: line count\n- `size`: formatted size (table) or bytes (json/csv)\n- `description`: truncated to desc-length with ellipsis\n- `modified`: last modified timestamp\n\n**Validation:**\n- Collection name must exist in manifest\n- Field names must be valid (path, type, lines, size, description, modified)\n- Format must be table, json, or csv\n\n### `cmd/dox/main.go` (MODIFY)\nRegister: `newFilesCommand()`\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes\n- `dox files goreleaser` shows table with default fields\n- `dox files goreleaser --json` shows JSON array\n- `dox files goreleaser --all` shows all files\n- `dox files goreleaser --fields path,lines` shows only those columns\n- `dox files goreleaser --format csv` outputs CSV\n- `dox files nonexistent` shows error listing available collections\n\n## Commit\n```bash\ngit add cmd/dox/files.go cmd/dox/main.go\ngit commit -m \"feat: implement dox files command with field selection\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:26:53.579818-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:39:48.405197-05:00","closed_at":"2026-02-08T20:39:48.405197-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-xbq","depends_on_id":"dox-32p","type":"blocks","created_at":"2026-02-08T19:36:45.194793-05:00","created_by":"Takin Profit"}]}
{"id":"dox-xsc","title":"Update README.md with documentation","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:29:06.690829-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T19:43:57.592937-05:00","closed_at":"2026-02-06T19:43:57.592937-05:00","close_reason":"Closed"}
{"id":"dox-y7c","title":"Write URL source tests","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:52.18145-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:33:12.286813-05:00","closed_at":"2026-02-06T18:33:12.286813-05:00","close_reason":"Closed"}
{"id":"dox-ys8","title":"Implement GitHub source with Trees API","status":"closed","priority":2,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-06T15:28:48.466364-05:00","created_by":"Takin Profit","updated_at":"2026-02-06T18:23:59.301838-05:00","closed_at":"2026-02-06T18:23:59.301838-05:00","close_reason":"Closed"}
{"id":"dox-zzv","title":"Implement manifest generator","description":"## Overview\nImplement the manifest generator that walks the .dox/ output directory, parses each file, and builds the manifest with metadata, descriptions, and outlines.\n\n## Dependencies\n- Manifest types and persistence must exist\n- All parsers must be implemented (markdown, mdx, text, typescript)\n\n## Files to Create\n\n### `internal/manifest/generator.go`\n```go\npackage manifest\n\nimport (\n    \"context\"\n    \"os\"\n    \"path/filepath\"\n    \"time\"\n\n    \"github.com/g5becks/dox/internal/config\"\n    \"github.com/g5becks/dox/internal/parser\"\n)\n\nconst (\n    maxParseSize = 50 * 1024 * 1024 // 50MB\n)\n\n// Generate creates a manifest by walking the output directory and parsing files.\n// It is non-fatal - errors on individual files are logged as warnings.\nfunc Generate(ctx context.Context, cfg *config.Config) error {\n    outputDir := cfg.Output\n    m := New()\n\n    // Build parser registry\n    parsers := []parser.Parser{\n        parser.NewMarkdownParser(),\n        parser.NewMDXParser(),\n        parser.NewTextParser(),\n        parser.NewTypeScriptParser(),\n    }\n\n    // Walk each source's output directory\n    for sourceName, sourceCfg := range cfg.Sources {\n        sourceDir := resolveSourceDir(outputDir, sourceName, sourceCfg)\n        \n        if _, err := os.Stat(sourceDir); os.IsNotExist(err) {\n            continue // Source not synced yet\n        }\n        \n        collection := \u0026Collection{\n            Name:     sourceName,\n            Type:     sourceCfg.Type,\n            Source:   resolveSourceLocation(sourceCfg),\n            Path:     sourceCfg.Path,\n            Ref:      sourceCfg.Ref,\n            LastSync: time.Now(),\n        }\n        \n        // Walk directory and parse files\n        err := filepath.WalkDir(sourceDir, func(path string, d os.DirEntry, err error) error {\n            if err != nil || d.IsDir() {\n                return err\n            }\n            \n            // Skip manifest and lock files\n            if d.Name() == ManifestFile || d.Name() == \".dox.lock\" {\n                return nil\n            }\n            \n            relPath, _ := filepath.Rel(sourceDir, path)\n            fileInfo, parseErr := parseFile(path, relPath, parsers)\n            if parseErr != nil {\n                // Non-fatal: log warning, skip file\n                return nil\n            }\n            \n            collection.Files = append(collection.Files, *fileInfo)\n            collection.TotalSize += fileInfo.Size\n            return nil\n        })\n        \n        if err != nil {\n            return err\n        }\n        \n        collection.FileCount = len(collection.Files)\n        m.Collections[sourceName] = collection\n    }\n\n    return m.Save(outputDir)\n}\n\n// parseFile reads a file and runs the appropriate parser.\nfunc parseFile(absPath string, relPath string, parsers []parser.Parser) (*FileInfo, error) {\n    // 1. Stat file for size and mod time\n    // 2. If size \u003e maxParseSize: return FileInfo with warning \"file_too_large\"\n    // 3. Read file content\n    // 4. If parser.IsBinary(content): skip (return error)\n    // 5. Find matching parser via CanParse()\n    // 6. If no parser matches: return basic FileInfo with type \"unknown\"\n    // 7. Run parser.Parse()\n    // 8. Build and return FileInfo with all metadata\n}\n\n// resolveSourceDir determines the output directory for a source.\nfunc resolveSourceDir(outputDir string, name string, src config.Source) string {\n    if src.Out != \"\" {\n        return filepath.Join(outputDir, src.Out)\n    }\n    return filepath.Join(outputDir, name)\n}\n\n// resolveSourceLocation returns a human-readable source location.\nfunc resolveSourceLocation(src config.Source) string {\n    if src.Repo != \"\" {\n        return src.Repo\n    }\n    return src.URL\n}\n```\n\n### `internal/manifest/generator_test.go`\nTests:\n- Generate with empty output directory (no collections)\n- Generate with single collection containing .md files\n- Generate with mixed file types (.md, .mdx, .txt, .tsx)\n- Generate skips binary files\n- Generate handles large files (\u003e50MB) with warning\n- Generate handles files with no matching parser (type \"unknown\")\n- Round-trip: generate then load and verify structure\n\nCreate test fixtures: set up temp directories with sample files of each type.\n\n## Patterns to Follow\n- Follow sync.go resolveSourceOutputDir pattern for source directory resolution\n- Use oops for errors\n- Non-fatal file parsing errors: log and continue\n\n## Acceptance Criteria\n- `task lint` has zero warnings or errors\n- `task build` succeeds\n- `task test` passes including new tests\n- Generator correctly produces manifest from test fixtures\n\n## Commit\n```bash\ngit add internal/manifest/generator.go internal/manifest/generator_test.go\ngit commit -m \"feat: implement manifest generator with file parsing\"\n```","status":"closed","priority":1,"issue_type":"task","owner":"techstar.dev@hotmail.com","created_at":"2026-02-08T19:24:06.51275-05:00","created_by":"Takin Profit","updated_at":"2026-02-08T20:45:03.208809-05:00","closed_at":"2026-02-08T20:45:03.208809-05:00","close_reason":"Closed","dependencies":[{"issue_id":"dox-zzv","depends_on_id":"dox-8a3","type":"blocks","created_at":"2026-02-08T19:36:18.457878-05:00","created_by":"Takin Profit"},{"issue_id":"dox-zzv","depends_on_id":"dox-0wr","type":"blocks","created_at":"2026-02-08T19:36:22.016367-05:00","created_by":"Takin Profit"},{"issue_id":"dox-zzv","depends_on_id":"dox-9dl","type":"blocks","created_at":"2026-02-08T19:36:24.879356-05:00","created_by":"Takin Profit"},{"issue_id":"dox-zzv","depends_on_id":"dox-a82","type":"blocks","created_at":"2026-02-08T19:36:28.251906-05:00","created_by":"Takin Profit"},{"issue_id":"dox-zzv","depends_on_id":"dox-5ci","type":"blocks","created_at":"2026-02-08T19:36:31.811318-05:00","created_by":"Takin Profit"}]}
